---
output: html_document
---

# Introducción proceso espacial bivariado

Martha Bohorquez

19/5/2022

## Librerías

```{r}
rm(list=ls())
library(geoR)
library(mvtnorm)
```

## Ubicaciones: En este caso se supone que ambos procesos están observados en los mismos lugares

```{r}
x=seq(0,1,len=3)
y=seq(0,1,len=4)
coordenadas=expand.grid(x,y)
Mat_dist=as.matrix(dist(coordenadas))
```

## Modelo lineal de coregionalización

```{r}
Cova1=function(h,a){exp(-h/a)}
Cova2=function(h,a){ifelse(h <= a, 1-1.5*(h/a)+0.5*(h/a)^3, 0)}
B1=matrix(c(26.3,0.3,0.3,2.1),nrow=2,byrow=T)
B2=matrix(c(2.1,1.3,1.3,17.5),nrow=2,byrow=T)
Mat_Cov_bloque11=B1[1,1]*Cova1(Mat_dist,1)+B2[1,1]*Cova2(Mat_dist,0.5)
Mat_Cov_bloque22=B1[2,2]*Cova1(Mat_dist,1)+B2[2,2]*Cova2(Mat_dist,0.5)
Mat_Cov_bloque12=B1[1,2]*Cova1(Mat_dist,1)+B2[1,2]*Cova2(Mat_dist,0.5)
Mat_Cov_bloque21=B1[2,1]*Cova1(Mat_dist,1)+B2[2,1]*Cova2(Mat_dist,0.5)
MAT_COV=rbind(cbind(Mat_Cov_bloque11,Mat_Cov_bloque12),cbind(Mat_Cov_bloque21,Mat_Cov_bloque22))
dim(MAT_COV)
```

```{r}
det(MAT_COV)
```


## Simulación de un proceso espacial Gaussiano bivariado

```{r}
sim1=rmvnorm(1,mean=rep(0,2*nrow(coordenadas)), sigma=MAT_COV)
datos=cbind(coordenadas,z1=sim1[1:12],z2=sim1[13:24])
```


## Cokriging

### Librerías

```{r}
rm(list=ls())
library(sp)
library(gstat)
library(sf)
library(rgdal)
library(ggplot2)
library(plotly)
library(Matrix)
```

### Descripción de los datos

Cokriging para las variables $NO2$, $O3$, y $NOX$. La variable de principal riesgo es ozono ($O3$), así que se usan las otras dos como covariables espaciales. Día 2020/01/16 A las 17 horas.

```{r}
datos <- read.csv("data_8_Cokriging/Air_polution_cdmx_2020_01_16_17h.csv")
datos <- datos[c("Estacion",
               "X",
               "Y",
               "NO2",
               "O3",
               "NOX")]

pander::pander((datos))
```


### Matrices de coregionalización.

#### Matriz definida positiva para el modelo Esférico.

```{r}
mat1 <- cbind(c(30, 30, 30),
              c(30, 50, 30),
              c(30, 30, 35))
#matriz definida positiva "cercana"
mat1 <- data.frame(as.matrix(nearPD(mat1)$mat))
names(mat1) <- c("NO2", "O3", "NOX")
row.names(mat1) <- c("NO2", "O3", "NOX")
pander::pander(mat1)
```

#### Matriz definida positiva para el modelo efecto Hueco.

```{r}
mat2 <- cbind(c(13.02, 24.5, 18.739),
              c(24.58, 46.4, 35.36),
              c(18.73, 35.36, 26.95))
mat2 <- data.frame(as.matrix(nearPD(mat2)$mat))
names(mat2) <- c("NO2", "O3", "NOX")
row.names(mat2) <- c("NO2", "O3", "NOX")
pander::pander(mat2)
```

### Definición de objeto en gstat

#### Semivariogramas univariados

```{r}
vgmno2 <- vgm(psill = mat1[1, 1],
            model = "Sph",
            range = 6096,
            add.to = vgm(psill = mat2[1, 1],
                         model = "Hol",
                         range = 2294))

vgmo3 <- vgm(psill = mat1[2, 2],
            model = "Sph",
            range = 6096,
            add.to = vgm(psill = mat2[2, 2],
                         model = "Hol",
                         range = 2294))

vgmnox <- vgm(psill = mat1[3, 3],
            model = "Sph",
            range = 6096,
            add.to = vgm(psill = mat2[3, 3],
                         model = "Hol",
                         range = 2294))

```


#### Semivarogramas cruzados (Bivariados)

```{r}
vgmno2_o3 <- vgm(psill = mat1[1, 2], model = "Sph",
            range = 6096,
            add.to = vgm(psill = mat2[1, 2],
                         model = "Hol",
                         range = 2294))

vgmno2_nox <- vgm(psill = mat1[1, 3],
            model = "Sph",
            range = 6096,
            add.to = vgm(psill = mat2[1, 3],
                         model = "Hol",
                         range = 2294))

vgmno3_nox <- vgm(psill = mat1[2, 3],
                  model = "Sph",
                  range = 6096,
                  add.to = vgm(psill = mat2[2, 3],
                               model = "Hol",
                               range = 2294))
```


#### gstat

```{r}
remove_na <- function(frame, vari_) {
    # Remove na from sp object
    datos1 <- frame
    bool <- !is.na(datos1@data[vari_])
    datos1@data <- datos1@data[bool, ]
    datos1@coords <- datos1@coords[bool, ]
    return(datos1)}

coordinates(datos) <- ~ X + Y

g_st <- gstat(NULL,
              id = "NO2",
              formula = NO2 ~ X + Y,
              model = vgmno2,
              data = remove_na(datos, "NO2"))

g_st <- gstat(g_st,
              id = "O3",
              formula = O3 ~ Y,
              model = vgmo3,
              data = remove_na(datos, "O3"))

g_st <- gstat(g_st,
              id = "NOX",
              formula = NOX ~ Y,
              model = vgmnox,
              data = remove_na(datos, "NOX"))
#Cruzados


g_st <- gstat(g_st,
              id = c("NO2", "O3"),
              model = vgmno2_o3)

g_st <- gstat(g_st,
              id = c("NO2", "NOX"),
              model = vgmno2_nox)

g_st <- gstat(g_st,
              id = c("O3", "NOX"),
              model = vgmno3_nox)


pander::pander(do.call(rbind, g_st$model)[, 1:3])
```


#### Estimación del semivariograma

```{r}
plot(variogram(g_st),
     model = g_st$model,
     pl = T,
     xlab = "Distancias",
     ylab = "Semivarianza")
```

#### Mapas de predicción de O3 con las covariables espaciales NO2 y NOX

```{r}
prediction_plot <- function(g_object, variable, map_path) {

    map <- readOGR(map_path)
    new <- sp::spsample(map, n = 100000, type = "regular")
    coordinates(new) ~ x1 + x2
    colnames(new@coords) <- c("X", "Y")

    predic <- predict(g_object, newdata = new)

    prediction <- data.frame(predic)

    pred <- paste(variable, ".pred", sep = "")

    plot <- ggplot(prediction, aes_string("X", "Y", fill = pred)) +
            geom_tile() +
            scale_fill_viridis_c() +
            theme_void()

    return(plot)}


variance_plot <- function(g_object, variable, map_path) {

    map <- readOGR(map_path)
    new <- sp::spsample(map, n = 10000, type = "regular")
    coordinates(new) ~ x1 + x2
    colnames(new@coords) <- c("X", "Y")

    predic <- predict(g_object, newdata = new)

    prediction <- data.frame(predic)

    var <- paste(variable, ".var", sep = "")

    plot <- ggplot(prediction, aes_string("X", "Y", fill = var)) +
            geom_tile() +
            scale_fill_viridis_c(option = "inferno",
                                 direction = -1) +
            theme_void()

    return(plot)}

cv_plot <- function(g_object, variable, map_path) {

    map <- readOGR(map_path)
    new <- sp::spsample(map, n = 10000, type = "regular")
    coordinates(new) ~ x1 + x2
    colnames(new@coords) <- c("X", "Y")

    predic <- predict(g_object, newdata = new)

    prediction <- data.frame(predic)
    pred <- paste(variable, ".pred", sep = "")
    var <- paste(variable, ".var", sep = "")
    aux <- abs(sqrt(prediction[var]) / abs(prediction[pred]))
    aux[aux > 1] <- 1
    prediction["cv"] <- aux

    plot <- ggplot(prediction, aes_string("X", "Y", fill = "cv")) +
            geom_tile() +
            scale_fill_viridis_c(option = "magma",
                                 direction = -1) +
            theme_void()

    return(plot)}


pl1 <- prediction_plot(g_st, "O3",
                       "data_8_Cokriging/SP/mpiosutm.shp")
```

```{r}
pl2 <- variance_plot(g_st, "O3",
                     "data_8_Cokriging/SP/mpiosutm.shp")
```

```{r}
pl3 <- cv_plot(g_st, "O3",
               "data_8_Cokriging/SP/mpiosutm.shp")
```

```{r}
ggplotly(pl1)
```

```{r}
ggplotly(pl2)
```

```{r}
ggplotly(pl3)
```

## Kriging en Geostad


### Ilustración del kriging simple espacio tiempo

#### librerías 



```{r}
rm(list=ls())
library(mvtnorm)
```

#### **Simulación no condicional de una realización de un campo aleatorio espacio temporal no separable usando el modelo de covarianza cressie1**

En primer lugar, se generar la grilla espacio temporal. Aquí suponemos n=6 ubicaciones espaciales y T=4 momentos en el tiempo, así en total son 24 ubicaciones espacio-tiempo. Se llevará a cabo la simulación y posteriormente se usará el predictor kriging con su respectiva estimación de varianza del error de predicción, en un punto no “observado”. Se asume conocida la función de covarianza. En la práctica esta matriz se puede estimar por métodos como maxima veorsimilitud, pseudoverosimilitud y métodos basados en mínimos cuadrados.

```{r}
x1 <- seq(0,3,len = 3)
x2 <- seq(1,6,len = 2)
t <- 1:4
grillaSpT=expand.grid(x1,x2,t)
#matriz de distancias (rezagos) espaciales
matDistSp=as.matrix(dist(grillaSpT[,1:2]))
#matriz de distancias (rezagos) temporales
matDistT=as.matrix(dist(grillaSpT[,3:3]))
cressie1=function(h,u,p){
  (p[1]^2/((p[2]^2*u^2+1)))*exp(-(p[3]^2*h^2)/(p[2]^2*u^2+1))}
##parámetros p, mu, que en este caso son p=c(0.4,1.7,1.9) y mu=0
sigma=cressie1(matDistSp,matDistT,p=c(0.15,1.7,1.9))
sim1=rmvnorm(1,mean=rep(0,nrow(grillaSpT)), sigma=sigma)
datos1=cbind(grillaSpT,t(sim1))
names(datos1)=c("x","y","t","z((x,y),t)")
matDistSp
```

```{r}
matDistT
```

```{r}
sigma
```

```{r}
datos1
```

- Se requiere predecir predecir en el tiempo $t=2.3$ y en el lugar $s_0=(1.5,2.7)$. Nótese que tanto el dominio espacial como el dominio temporal con continuos y fijos. A continuación se presenta el procedimiento para llevar a cabo Kriging simple con su respectiva varianza de error de predicción estimada

```{r}
grillaSpT0=rbind(expand.grid(x1,x2,t),c(1.5,2.7,2.3))
matDistSp0=as.matrix(dist(grillaSpT0[,1:2]))
matDistT0=as.matrix(dist(grillaSpT0[,3:3]))
sigma0=cressie1(matDistSp0,matDistT0,p=c(0.15,1.7,1.9))
#vector de covarianzas entre la coordenada a predecir y las observadas
sigma0
```

```{r}
lambda=solve(sigma)%*%sigma0[25,-25]
lambda
```

```{r}
z_pred0=t(lambda)%*%datos1[,4]
z_pred0
```

```{r}
VarErropred0=sigma[1,1]-t(sigma0[25,-25])%*%solve(sigma)%*%sigma0[25,-25]
VarErropred0
```

#### **Algunas funciones de covarianza espacio temporal no separables**

```{r}
##Funciones de covarianza espacio temporal p vector de parámetros para cada modelo
exp_esp_temp=function(h,u,p){
  ((p[1])^2)*exp(-h/p[2]-u/p[3])}
gauss_esp_temp=function(h,u,p){
  (p[1]^2)*exp(-(h/p[2])^2-(u/p[3])^2)}
cressie1=function(h,u,p){
  (p[1]^2/((p[2]^2*u^2+1)))*exp(-(p[3]^2*h^2)/(p[2]^2*u^2+1))}
Gneiting1=function(h,u,p){
  p[1]^2/((p[2]*u^(2*p[3])+1)^(p[4]))*exp(-(p[6]*h^(2*p[5]))/((p[2]*u^(2*p[3])+1)^(p[4]*p[5])))}
Gneiting2=function(h,u,sigma,p){
  p[1]^2/((2^(p[3]-1))*p[7](p[3])*(p[2]*u^(2*p[3])+1)^(p[4]+p[5]))*
    (((p[6]*h)/((p[2]*u^(2*p[3])+1)^(p[5]/2)))^p[3])*
    besselK(((p[6]*h)/((p[2]*u^(2*p[3])+1)^(p[5]/2))),p[3])}
Iaco_Cesare=function(h,u,a,b,c){
  (1+h^p[1]+u^p[2])^(-p[3])}
```

##### C R E S S I E - H U A N G (1999)

```{r}
#sigma:desviacion estandar, a es el parámetros de escala del tiempo, b es el parámetros de escala del espacio, d es la dimensión espacial; a,b positivos
CH_1=function(h,u,p,d){
  (p[1]^2/((p[2]^2*u^2+1)^(d/2)))*exp(-(p[3]^2*h^2)/(p[2]^2*u^2+1))}
CH_2=function(h,u,p,d){
  (p[1]^2/((p[2]*abs(u)+1)^(d/2)))*exp(-(p[3]^2*h^2)/(p[2]*abs(u)+1))}
CH_3=function(h,u,p,d){
  p[1]^2*((p[2]^2)*(u^2)+1)/(((p[2]^2)*(u^2)+1)^2+(p[3]^2)*h^2)^((d+1)/2)}
CH_4=function(h,u,p,d){
  p[1]^2*(p[2]*abs(u)+1)/((p[2]*abs(u)+1)^2+(p[3]^2)*h^2)^((d+1)/2)}

#el caso mas general de C R E S S I E - H U A N G (1999) es cuando d=2, entonces queda
CH_1=function(h,u,p){
  (p[1]^2/((p[2]^2*u^2+1)))*exp(-(p[3]^2*h^2)/(p[2]^2*u^2+1))}
CH_2=function(h,u,p){
  (p[1]^2/((p[2]*abs(u)+1)))*exp(-(p[3]^2*h^2)/(p[2]*abs(u)+1))}
CH_3=function(h,u,p){
  p[1]^2*((p[2]^2)*(u^2)+1)/(((p[2]^2)*(u^2)+1)^2+(p[3]^2)*h^2)^((3)/2)}
CH_4=function(h,u,p){
  p[1]^2*(p[2]*abs(u)+1)/((p[2]*abs(u)+1)^2+(p[3]^2)*h^2)^((3)/2)}
```

##### Gneiting (2002), combina fun1, fun2 y psi en Gneiting

```{r}
#fun1
phi1=function(r,c,gama,v){
  v*exp(-c*r^gama)}                                           #c>0, 0<gama<=1, siempre v=1
phi2=function(r,c,gama,v){
  ((2^(v-1))*gamma(v))^(-1)*(c*r^0.5)^v*besselK(c*r^0.5,v)}   #c>0, v>0
phi3=function(r,c,gama,v){
  (1+c*r^gama)^(-v)}                                          #c>0, 0<gama<=1, v>0
phi4=function(r,c,gama,v){
  gama*(2^v)*(exp(c*r^0.5)+exp(-c*r^0.5))^(-v)}               #c>0, v>0, siempre gama=1

#fun2
psi1=function(r,a,alpha,beta){
  (a*r^alpha+1)^beta}                                         #a>0, 0<alpha<=1, 0<=beta<=1
psi2=function(r,a,alpha,beta){
  log(a*r^alpha+beta)/log(beta)}                              #a>0, beta>1,  0<alpha<=1
psi3=function(r,a,alpha,beta){
  (a*r^alpha+beta)/(beta*(a*r^alpha+1))}                      #a>0, 0<beta<=1   0<alpha<=1  

#Cualquier combinación genera una función de covarianza válida
Gneiting=function(h,u,sigma,d,a,alpha,beta,c,gama,v,psi,phi){
  (sigma^2/(psi((abs(u)^2),a,alpha,beta))^(d/2))*phi(h^2/(psi(abs(u)^2,a,alpha,beta)),c,gama,v)}

#el caso mas general de Gneiting (2002) es cuando d=2, entonces queda
Gneiting=function(h,u,sigma,a,alpha,beta,c,gama,v,psi,phi){
  (sigma^2/(psi((abs(u)^2),a,alpha,beta)))*phi(h^2/(psi(abs(u)^2,a,alpha,beta)),c,gama,v)}
```

```{r}
####IACO_CESSARE
C_IACO_CESSARE=function(h,u,sigma,a,b,alpha,beta,gama){
  (1 + (h/a)^alpha + (u/b)^beta)^(-gama)}
```

```{r}
#(Porcu, 2007) Basado en la función de supervivencia de Dagum 
#función de Dagum
Dagum=function(r,lambda,theta,epsilon){
  1-1/(1+lambda*r^(-theta))^epsilon}                                                                                     #lamdba, theta in (0,7), epsilon in (0,7)
Dagumm=function(r,lambda,theta,epsilon){
  ifelse(r==0,1,Dagum(r,lambda,theta,epsilon))}

Porcu_sep=function(h,u,lambda_h,theta_h,epsilon_h,lambda_u,theta_u,epsilon_u){
  Dagumm(h,lambda_h,theta_h,epsilon_h)*Dagumm(u,lambda_u,theta_u,epsilon_u)}      
Porcu_Nsep=function(h,u,lambda_h,theta_h,epsilon_h,lambda_u,theta_u,epsilon_u,vartheta){
  vartheta*Dagumm(h,lambda_h,theta_h,epsilon_h)+(1-vartheta)*Dagumm(u,lambda_u,theta_u,epsilon_u)}
```


