[["index.html", "03-EstudioMercadeoEspacial Pilar Montilla, Martha Bohorquez and Rafael Rentería Chapter 1 Simulación Proceso Espacio Temporal 1.1 Funciones 1.2 CH 1 no separable 1.3 CH3 no separable 1.4 CH 4", " 03-EstudioMercadeoEspacial Pilar Montilla, Martha Bohorquez and Rafael Rentería …. 2022-11-16 Chapter 1 Simulación Proceso Espacio Temporal 1.1 Funciones ##Funciones de covarianza espacio temporal exp_esp_temp=function(h,u,p){((p[1])^2)*exp(-h/p[2]-u/p[3])} gauss_esp_temp=function(h,u,p){(p[1]^2)*exp(-(h/p[2])^2-(u/p[3])^2)} cressie1=function(h,u,p){(p[1]^2/((p[2]^2*u^2+1)))*exp(-(p[3]^2*h^2)/(p[2]^2*u^2+1))} Gneiting1=function(h,u,p){p[1]^2/((p[2]*u^(2*p[3])+1)^(p[4]))*exp(-(p[6]*h^(2*p[5]))/((p[2]*u^(2*p[3])+1)^(p[4]*p[5])))} #Gneiting2=function(h,u,sigma,p){p[1]^2/((2^(p[3]-1))*p[7](p[3])*(p[2]*u^(2*p[3])+1)^(p[4]+p[5]))*(((p[6]*h)/((p[2]*u^(2*[3])+1)^(p[5]/2)))^p[3])*besselK(((p[6]*h)/((p[2]*u^(2*[3])+1)^(p[5]/2))),p[3])} Iaco_Cesare=function(h,u,a,b,c){(1+h^p[1]+u^p[2])^(-p[3])} #separables mas comunes: gaussiano y exponencial p=(sigma,a,b) Gaussiano=function(p,h,u){p[1]^2*exp(-p[2]^2*u^2-p[3]^2*h^2)} Exponencial=function(p,h,u){p[1]^2*exp(-p[2]^2*u-p[3]^2*h)} #C R E S S I E - H U A N G (1999) #sigma:desviacion estandar, a es el par?metros de escala del tiempo, b es el par?metros de escala del espacio, d es la dimensi?n espacial; a,b positivos CH_1=function(h,u,p,d){(p[1]^2/((p[2]^2*u^2+1)^(d/2)))*exp(-(p[3]^2*h^2)/(p[2]^2*u^2+1))} CH_2=function(h,u,p,d){(p[1]^2/((p[2]*abs(u)+1)^(d/2)))*exp(-(p[3]^2*h^2)/(p[2]*abs(u)+1))} CH_3=function(h,u,p,d){p[1]^2*((p[2]^2)*(u^2)+1)/(((p[2]^2)*(u^2)+1)^2+(p[3]^2)*h^2)^((d+1)/2)} CH_4=function(h,u,p,d){p[1]^2*(p[2]*abs(u)+1)/((p[2]*abs(u)+1)^2+(p[3]^2)*h^2)^((d+1)/2)} #el caso mas general de C R E S S I E - H U A N G (1999) es cuando d=2, entonces queda CH_1=function(h,u,p){(p[1]^2/((p[2]^2*u^2+1)))*exp(-(p[3]^2*h^2)/(p[2]^2*u^2+1))} CH_2=function(h,u,p){(p[1]^2/((p[2]*abs(u)+1)))*exp(-(p[3]^2*h^2)/(p[2]*abs(u)+1))} CH_3=function(h,u,p){p[1]^2*((p[2]^2)*(u^2)+1)/(((p[2]^2)*(u^2)+1)^2+(p[3]^2)*h^2)^((3)/2)} CH_4=function(h,u,p){p[1]^2*(p[2]*abs(u)+1)/((p[2]*abs(u)+1)^2+(p[3]^2)*h^2)^((3)/2)} ####Gneiting (2002), combina fun1, fun2 y psi en Gneiting##### #fun1 phi1=function(r,c,gama,v){v*exp(-c*r^gama)} #c&gt;0, 0&lt;gama&lt;=1, siempre v=1 phi2=function(r,c,gama,v){((2^(v-1))*gamma(v))^(-1)*(c*r^0.5)^v*besselK(c*r^0.5,v)} #c&gt;0, v&gt;0 phi3=function(r,c,gama,v){(1+c*r^gama)^(-v)} #c&gt;0, 0&lt;gama&lt;=1, v&gt;0 phi4=function(r,c,gama,v){gama*(2^v)*(exp(c*r^0.5)+exp(-c*r^0.5))^(-v)} #c&gt;0, v&gt;0, siempre gama=1 #fun2 psi1=function(r,a,alpha,beta){(a*r^alpha+1)^beta} #a&gt;0, 0&lt;alpha&lt;=1, 0&lt;=beta&lt;=1 psi2=function(r,a,alpha,beta){log(a*r^alpha+beta)/log(beta)} #a&gt;0, beta&gt;1, 0&lt;alpha&lt;=1 psi3=function(r,a,alpha,beta){(a*r^alpha+beta)/(beta*(a*r^alpha+1))} #a&gt;0, 0&lt;beta&lt;=1 0&lt;alpha&lt;=1 #Cualquier combinaci?n genera una funci?n de covarianza v?lida Gneiting=function(h,u,sigma,d,a,alpha,beta,c,gama,v,psi,phi){(sigma^2/(psi((abs(u)^2),a,alpha,beta))^(d/2))*phi(h^2/(psi(abs(u)^2,a,alpha,beta)),c,gama,v)} #el caso mas general de Gneiting (2002) es cuando d=2, entonces queda Gneiting=function(h,u,sigma,a,alpha,beta,c,gama,v,psi,phi){(sigma^2/(psi((abs(u)^2),a,alpha,beta)))*phi(h^2/(psi(abs(u)^2,a,alpha,beta)),c,gama,v)} ####IACO_CESSARE C_IACO_CESSARE=function(h,u,sigma,a,b,alpha,beta,gama){(1 + (h/a)^alpha + (u/b)^beta)^(-gama)} #(Porcu, 2007) Basado en la funci?n de supervivencia de Dagum #funci?n de Dagum Dagum=function(r,lambda,theta,epsilon){1-1/(1+lambda*r^(-theta))^epsilon} #lamdba, theta in (0,7), epsilon in (0,7) Dagumm=function(r,lambda,theta,epsilon){ifelse(r==0,1,Dagum(r,lambda,theta,epsilon))} Porcu_sep=function(h,u,lambda_h,theta_h,epsilon_h,lambda_u,theta_u,epsilon_u){Dagumm(h,lambda_h,theta_h,epsilon_h)*Dagumm(u,lambda_u,theta_u,epsilon_u)} Porcu_Nsep=function(h,u,lambda_h,theta_h,epsilon_h,lambda_u,theta_u,epsilon_u,vartheta){vartheta*Dagumm(h,lambda_h,theta_h,epsilon_h)+(1-vartheta)*Dagumm(u,lambda_u,theta_u,epsilon_u)} 1.2 CH 1 no separable ###CH 1 no separable library(mvtnorm) #generar la grilla espacio temporal x1 &lt;- seq(0,30,by = 5) x2 &lt;- seq(10,60,by = 7) t &lt;- seq(1,20,len=10) grillaSpT=expand.grid(x1,x2,t) matDistSp=as.matrix(dist(grillaSpT[,1:2])) matDistT=as.matrix(dist(grillaSpT[,3:3])) ##parameters p, mu, que en este caso son p=c(7,2,1) y mu=120 sigma=cressie1(matDistSp,matDistT,p=c(7,2,1)) sim1=rmvnorm(1,mean=rep(120,nrow(grillaSpT)), sigma=sigma) datos1=cbind(grillaSpT,t(sim1)) names(datos1)=c(&quot;x&quot;,&quot;y&quot;,&quot;t&quot;,&quot;z((x,y),t)&quot;) #View(datos1) grillaSp=expand.grid(x1,x2) colnames(grillaSp)=c(&quot;x&quot;,&quot;y&quot;) rownames(grillaSp)=paste(&quot;S&quot;,1:nrow(grillaSp)) datos1_ord=datos1[order(datos1$x, datos1$y, datos1$t),] dataSim1=matrix(c(datos1_ord[,4]),nrow=length(t),ncol=nrow(grillaSp),byrow=F) colnames(dataSim1)=rownames(grillaSp) rownames(dataSim1)=t write.table(dataSim1,&quot;dataSim1.txt&quot;) “” CH 2 no sepaarable #CH 2 no separable library(mvtnorm) #generar la grilla espacio temporal x1 &lt;- seq(0,30,by = 6) x2 &lt;- seq(10,60,by = 8) t &lt;- seq(1,20,len=10) grillaSpT=expand.grid(x1,x2,t) matDistSp=as.matrix(dist(grillaSpT[,1:2])) matDistT=as.matrix(dist(grillaSpT[,3:3])) ##parameters p, mu, que en este caso son p=c(7,2,1) y mu=120 sigma=CH_2(matDistSp,matDistT,p=c(10,3,4)) sim2=rmvnorm(1,mean=rep(34,nrow(grillaSpT)), sigma=sigma) datos2=cbind(grillaSpT,t(sim2)) names(datos2)=c(&quot;x&quot;,&quot;y&quot;,&quot;t&quot;,&quot;zz((x,y),t)&quot;) #View(datos2) grillaSp=expand.grid(x1,x2) colnames(grillaSp)=c(&quot;x&quot;,&quot;y&quot;) rownames(grillaSp)=paste(&quot;S&quot;,1:nrow(grillaSp)) datos2_ord=datos2[order(datos2$x, datos2$y, datos2$t),] dataSim2=matrix(c(datos2_ord[,4]),nrow=length(t),ncol=nrow(grillaSp),byrow=F) colnames(dataSim2)=rownames(grillaSp) rownames(dataSim2)=t write.table(dataSim2,&quot;dataSim2.txt&quot;) class(dataSim2) ## [1] &quot;matrix&quot; &quot;array&quot; 1.3 CH3 no separable #CH 3 no separable x1 &lt;- seq(0,30,by = 5) x2 &lt;- seq(10,60,by = 7) grillaSp=expand.grid(x1,x2) colnames(grillaSp)=c(&quot;x&quot;,&quot;y&quot;) rownames(grillaSp)=paste(&quot;S&quot;,1:nrow(grillaSp)) t &lt;- seq(1,20,len=10) grillaSpT=expand.grid(x1,x2,t) matDistSp=as.matrix(dist(grillaSpT[,1:2])) matDistT=as.matrix(dist(grillaSpT[,3:3])) ##parameters p, mu, que en este caso son p=c(7,2,1) y mu=120 sigma=CH_3(matDistSp,matDistT,p=c(6,2.5,3.2)) sim3=rmvnorm(1,mean=rep(34,nrow(grillaSpT)), sigma=sigma) datos2=cbind(grillaSpT,t(sim3)) names(datos2)=c(&quot;x&quot;,&quot;y&quot;,&quot;t&quot;,&quot;zz((x,y),t)&quot;) #View(datos2) datos3 = datos2 datos3_ord=datos3[order(datos3$x, datos3$y, datos3$t),] dataSim3=matrix(c(datos3_ord[,4]),nrow=length(t),ncol=nrow(grillaSp),byrow=F) colnames(dataSim3)=rownames(grillaSp) rownames(dataSim3)=t 1.4 CH 4 #caso 4 library(mvtnorm) #generar la grilla espacio temporal x1 &lt;- seq(1,35,by = 7) x2 &lt;- seq(10,60,by = 10) grillaSp=expand.grid(x1,x2) colnames(grillaSp)=c(&quot;x&quot;,&quot;y&quot;) rownames(grillaSp)=paste(&quot;S&quot;,1:nrow(grillaSp)) t &lt;- seq(1,20,len=10) grillaSpT=expand.grid(x1,x2,t) matDistSp=as.matrix(dist(grillaSpT[,1:2])) matDistT=as.matrix(dist(grillaSpT[,3:3])) ##parameters p, mu, que en este caso son p=c(7,2,1) y mu=120 sigma=CH_3(matDistSp,matDistT,p=c(6,2.5,3.2)) sim4=rmvnorm(1,mean=rep(34,nrow(grillaSpT)), sigma=sigma) datos4=cbind(grillaSpT,t(sim4)) names(datos4)=c(&quot;x&quot;,&quot;y&quot;,&quot;t&quot;,&quot;zz((x,y),t)&quot;) #View(datos4) datos4_ord=datos4[order(datos4$x, datos4$y, datos4$t),] dataSim4=matrix(c(datos4_ord[,4]),nrow=length(t),ncol=nrow(grillaSp),byrow=F) colnames(dataSim4)=rownames(grillaSp) rownames(dataSim4)=t "],["spatial-modeling-leukemia.html", "Chapter 2 Spatial modeling leukemia 2.1 Mortality 2.2 Incidence", " Chapter 2 Spatial modeling leukemia 2.1 Mortality Spatial modeling of incidence and mortality childhood leukemia based on Colombian armed conflict and poverty for children born during the years 2002-2013 2.1.1 Packages Mortality rm(list=ls()) require(rgdal) require(pscl) require(sf) require(spdep) require(spatialreg) #test.W, scores.listw require(stringr) require(performance) require(AER) require(ggplot2) require(vcdExtra) require(dbscan) 2.1.2 Code Mortality Reading the shapefile of 1124 Colombian municipalities, defining the Coordinate Reference System and centroid and building some variables #Reading the shapefile of 1124 Colombian municipalities muncol &lt;- rgdal::readOGR(dsn=&quot;Armed_Conflict_Vs_Leukemia/muncol.shp&quot;) ## OGR data source with driver: ESRI Shapefile ## Source: &quot;/home/jncc/Documents/Notebooks/Monitorias/Bookdown/Cuadernos/Armed_Conflict_Vs_Leukemia/muncol.shp&quot;, layer: &quot;muncol&quot; ## with 1124 features ## It has 17 fields muncol=spTransform(muncol,CRS(&quot;+init=epsg:21897&quot;)) (l &lt;- length(muncol)) ## [1] 1124 #Representative coordinate (centroid) options(warn = -1) xy0=data.frame(x=muncol$x,y=muncol$y) coordinates(xy0) &lt;- c(&#39;x&#39;,&#39;y&#39;) proj4string(xy0) &lt;- CRS(&quot;+init=epsg:4326&quot;) xy0=spTransform(xy0,CRS(&quot;+init=epsg:21897&quot;)) ###Loops for avoiding NA r &lt;- sum(muncol$Ndeaths)/sum(muncol$NPop) for (i in 1:l){ if(muncol$NPop[i]==0){ muncol$EsperadosDeNCancer[i] &lt;- 1 } else{ muncol$EsperadosDeNCancer[i] &lt;- muncol$NPop[i]*r } } muncol$IICA_Cat=muncol$IICA_Ca muncol$IICA_Cat=str_replace_all(muncol$IICA_Cat,&quot;Bajo&quot;, &quot;Low&quot;) muncol$IICA_Cat=str_replace_all(muncol$IICA_Cat,&quot;Medio&quot;, &quot;Medium&quot;) muncol$IICA_CatLow=ifelse(muncol$IICA_Cat==&quot;Low&quot;,1,0) muncol$IICA_CatMed=ifelse(muncol$IICA_Cat==&quot;Medium&quot;,1,0) muncol$IICA_High=as.character(1-(muncol$IICA_CatLow+muncol$IICA_CatMed)) muncol$UBN=muncol$NBI Modeling leukemia Mortality Rate (LR) in terms of Colombian armed conflict index, poverty, rurality and health coverage. First, the usual Poisson regression model with mortality rate as response variable is estimated. glmbaseLMR&lt;-glm(Ndeaths ~IICA_High+UBN+Per_Rur+Cobertura+offset(log(EsperadosDeNCancer)), family = poisson,data = muncol) anova(glmbaseLMR) ## Analysis of Deviance Table ## ## Model: poisson, link: log ## ## Response: Ndeaths ## ## Terms added sequentially (first to last) ## ## ## Df Deviance Resid. Df Resid. Dev ## NULL 1123 799.92 ## IICA_High 1 0.694 1122 799.22 ## UBN 1 43.405 1121 755.82 ## Per_Rur 1 4.017 1120 751.80 ## Cobertura 1 9.185 1119 742.62 muncol$residLMR=residuals(glmbaseLMR) summary(glmbaseLMR) ## ## Call: ## glm(formula = Ndeaths ~ IICA_High + UBN + Per_Rur + Cobertura + ## offset(log(EsperadosDeNCancer)), family = poisson, data = muncol) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -2.9317 -0.5949 -0.4108 -0.2389 3.3300 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -0.583783 0.307508 -1.898 0.05764 . ## IICA_High1 0.107822 0.084777 1.272 0.20343 ## UBN -0.007902 0.003003 -2.632 0.00850 ** ## Per_Rur -0.002705 0.002370 -1.141 0.25380 ## Cobertura 0.991687 0.336039 2.951 0.00317 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for poisson family taken to be 1) ## ## Null deviance: 799.92 on 1123 degrees of freedom ## Residual deviance: 742.62 on 1119 degrees of freedom ## AIC: 1271.7 ## ## Number of Fisher Scoring iterations: 6 Rurality and conflict armed index are not statistically significant in this first auxiliar model. However, we maintain these variables in the rest of the analysis and review its significance in the final model. Checking excess zeros by comparison between the number of zeros predicted by the model with the observed number of zeros. Also checking overdispersion. mu_LMR &lt;- predict(glmbaseLMR, type = &quot;response&quot;) # predict expected mean count expLMR &lt;- sum(dpois(x = 0, lambda = mu_LMR)) # sum the probabilities of a zero count for each mean round(expLMR) #predicted number of zeros ## [1] 898 sum(muncol$Ndeaths &lt; 1) #observed number of zeros ## [1] 907 zero.test(muncol$Ndeaths) #score test (van den Broek, 1995) ## Score test for zero inflation ## ## Chi-square = 902.95398 ## df = 1 ## pvalue: &lt; 0.000000000000000222 ##Checking overdispersion dispersiontest(glmbaseLMR) #Cameron &amp; Trivedi (1990) ## ## Overdispersion test ## ## data: glmbaseLMR ## z = 2.2049, p-value = 0.01373 ## alternative hypothesis: true dispersion is greater than 1 ## sample estimates: ## dispersion ## 1.109361 The observed frequency of zeroes in data exceeds the predicted in the Leukemia mortality rate (LMR) model. Also, overdispersion is detected. Now, to validate the independence assumption, first, it is necessary to define spatial weighting possible matrices. rook_nb_b=nb2listw(poly2nb(muncol,queen=FALSE), style=&quot;B&quot;,zero.policy = TRUE) rook_nb_w=nb2listw(poly2nb(muncol,queen=FALSE), style=&quot;W&quot;,zero.policy = TRUE) queen_nb_b=nb2listw(poly2nb(muncol,queen=TRUE), style=&quot;B&quot;,zero.policy = TRUE) queen_nb_w=nb2listw(poly2nb(muncol,queen=TRUE), style=&quot;W&quot;,zero.policy = TRUE) #Graphs neighbours trinb=tri2nb(xy0) options(warn = -1) tri_nb_b=nb2listw(tri2nb(xy0), style=&quot;B&quot;,zero.policy = TRUE) tri_nb_w=nb2listw(tri2nb(xy0), style=&quot;W&quot;,zero.policy = TRUE) soi_nb_b=nb2listw(graph2nb(soi.graph(trinb,xy0)), style=&quot;B&quot;,zero.policy = TRUE) soi_nb_w=nb2listw(graph2nb(soi.graph(trinb,xy0)), style=&quot;W&quot;,zero.policy = TRUE) relative_nb_b=nb2listw(graph2nb(relativeneigh(xy0), sym=TRUE), style=&quot;B&quot;,zero.policy = TRUE) relative_nb_w=nb2listw(graph2nb(relativeneigh(xy0), sym=TRUE), style=&quot;W&quot;,zero.policy = TRUE) gabriel_nb_b=nb2listw(graph2nb(gabrielneigh(xy0), sym=TRUE), style=&quot;B&quot;,zero.policy = TRUE) gabriel_nb_w=nb2listw(graph2nb(gabrielneigh(xy0), sym=TRUE), style=&quot;W&quot;,zero.policy = TRUE) #Distance neighbours knn1_nb_b=nb2listw(knn2nb(knearneigh(xy0, k = 1)), style=&quot;B&quot;,zero.policy = TRUE) knn1_nb_w=nb2listw(knn2nb(knearneigh(xy0, k = 1)), style=&quot;W&quot;,zero.policy = TRUE) knn2_nb_b=nb2listw(knn2nb(knearneigh(xy0, k = 2)), style=&quot;B&quot;,zero.policy = TRUE) knn2_nb_w=nb2listw(knn2nb(knearneigh(xy0, k = 2)), style=&quot;W&quot;,zero.policy = TRUE) knn3_nb_b=nb2listw(knn2nb(knearneigh(xy0, k = 3)), style=&quot;B&quot;,zero.policy = TRUE) knn3_nb_w=nb2listw(knn2nb(knearneigh(xy0, k = 3)), style=&quot;W&quot;,zero.policy = TRUE) knn4_nb_b=nb2listw(knn2nb(knearneigh(xy0, k = 4)), style=&quot;B&quot;,zero.policy = TRUE) knn4_nb_w=nb2listw(knn2nb(knearneigh(xy0, k = 4)), style=&quot;W&quot;,zero.policy = TRUE) mat=list(rook_nb_b,rook_nb_w, queen_nb_b,queen_nb_w, tri_nb_b,tri_nb_w, soi_nb_b,soi_nb_w, gabriel_nb_b,gabriel_nb_w, relative_nb_b,relative_nb_w, knn1_nb_b,knn1_nb_w, knn2_nb_b,knn2_nb_w, knn3_nb_b,knn3_nb_w, knn4_nb_b,knn4_nb_w) Testing spatial autocorrelation using Moran index test based on weighting matrices built in the last step. Note that with all weighting matrices we obtain a significant spatial autocorrelation. aux=numeric(0) options(warn = -1) { for(i in 1:length(mat)) aux[i]=moran.test(muncol$residLMR,mat[[i]],alternative=&quot;two.sided&quot;)$&quot;statistic&quot; aux } ## [1] 1.238996 1.473832 1.428553 1.629968 1.367192 1.592464 1.921616 2.011106 1.860100 2.247294 2.629440 2.588622 1.099401 1.099401 ## [15] 2.469062 2.469062 3.088200 3.088200 3.450986 3.450986 which.max(aux) ## [1] 19 moran.test(muncol$residLMR, mat[[which.max(aux)]], alternative=&quot;two.sided&quot;) ## ## Moran I test under randomisation ## ## data: muncol$residLMR ## weights: mat[[which.max(aux)]] ## ## Moran I statistic standard deviate = 3.451, p-value = 0.0005585 ## alternative hypothesis: two.sided ## sample estimates: ## Moran I statistic Expectation Variance ## 0.0672352967 -0.0008904720 0.0003897053 First, Poisson Hurdle model is estimated without consider spatial autocorrelation. mod.hurdleLMR &lt;- hurdle(Ndeaths ~IICA_High+UBN+Per_Rur+Cobertura+offset(log(EsperadosDeNCancer))|IICA_High+UBN+Per_Rur+Cobertura+offset(log(EsperadosDeNCancer)),data = muncol,dist = &quot;poisson&quot;, zero.dist = &quot;binomial&quot;) resid_Pois_Hurdle=residuals(mod.hurdleLMR,&quot;response&quot;) summary(mod.hurdleLMR) ## ## Call: ## hurdle(formula = Ndeaths ~ IICA_High + UBN + Per_Rur + Cobertura + offset(log(EsperadosDeNCancer)) | IICA_High + UBN + ## Per_Rur + Cobertura + offset(log(EsperadosDeNCancer)), data = muncol, dist = &quot;poisson&quot;, zero.dist = &quot;binomial&quot;) ## ## Pearson residuals: ## Min 1Q Median 3Q Max ## -1.6105 -0.4155 -0.2926 -0.1781 7.8519 ## ## Count model coefficients (truncated poisson with log link): ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 0.0131708 0.3793725 0.035 0.9723 ## IICA_High1 0.2239159 0.1048208 2.136 0.0327 * ## UBN -0.0006294 0.0050823 -0.124 0.9014 ## Per_Rur -0.0064173 0.0049162 -1.305 0.1918 ## Cobertura 0.1702217 0.4227398 0.403 0.6872 ## Zero hurdle model coefficients (binomial with logit link): ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -1.013658 0.570592 -1.777 0.075650 . ## IICA_High1 -0.091317 0.177363 -0.515 0.606652 ## UBN -0.011792 0.004690 -2.514 0.011928 * ## Per_Rur -0.005190 0.003982 -1.303 0.192473 ## Cobertura 2.283308 0.624231 3.658 0.000254 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Number of iterations in BFGS optimization: 10 ## Log-likelihood: -624 on 10 Df pR2(mod.hurdleLMR) ## fitting null model for pseudo-r2 ## llh llhNull G2 McFadden r2ML r2CU ## -623.9804020 -1369.2239672 1490.4871304 0.5442817 0.7344776 0.8048896 moran.test(resid_Pois_Hurdle, mat[[which.max(aux)]], alternative=&quot;two.sided&quot;) ## ## Moran I test under randomisation ## ## data: resid_Pois_Hurdle ## weights: mat[[which.max(aux)]] ## ## Moran I statistic standard deviate = 4.8924, p-value = 0.0000009964 ## alternative hypothesis: two.sided ## sample estimates: ## Moran I statistic Expectation Variance ## 0.0935041339 -0.0008904720 0.0003722701 Only Conflict armed index predictor is significant but model residuals are significantly spatially autocorrelated. So, we use spatial filtering and check significance again. Below we find Moran Eigenvectors. MEpoisLMR &lt;- spatialreg::ME(Ndeaths ~ IICA_High+UBN+Per_Rur+Cobertura+offset(log(EsperadosDeNCancer)),data=muncol,family=&quot;poisson&quot;,listw=knn4_nb_b, alpha=0.02, verbose=TRUE) ## eV[,11], I: 0.02918226 ZI: NA, pr(ZI): 0.08 MoranEigenVLMR=data.frame(fitted(MEpoisLMR)) #summary(MoranEigenVLMR) Now, we used Poisson Hurdle model to manage the overdispersion due to zero excess and Moran eigenfunctions are included as additional explanatory variables, so that spatial autocorrelation is considered. mod.hurdleLMR &lt;- hurdle(Ndeaths ~IICA_High+UBN+Per_Rur+Cobertura+fitted(MEpoisLMR)+offset(log(EsperadosDeNCancer))|IICA_High+UBN+Per_Rur+Cobertura+offset(log(EsperadosDeNCancer)),data = muncol,dist = &quot;poisson&quot;, zero.dist = &quot;binomial&quot;) resid_Pois_Hurdle=residuals(mod.hurdleLMR,&quot;response&quot;) summary(mod.hurdleLMR) ## ## Call: ## hurdle(formula = Ndeaths ~ IICA_High + UBN + Per_Rur + Cobertura + fitted(MEpoisLMR) + offset(log(EsperadosDeNCancer)) | ## IICA_High + UBN + Per_Rur + Cobertura + offset(log(EsperadosDeNCancer)), data = muncol, dist = &quot;poisson&quot;, zero.dist = &quot;binomial&quot;) ## ## Pearson residuals: ## Min 1Q Median 3Q Max ## -1.6969 -0.4153 -0.2920 -0.1791 7.8744 ## ## Count model coefficients (truncated poisson with log link): ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 0.374295 0.391853 0.955 0.33948 ## IICA_High1 0.286868 0.104433 2.747 0.00602 ** ## UBN -0.010727 0.005917 -1.813 0.06986 . ## Per_Rur -0.003464 0.005096 -0.680 0.49664 ## Cobertura -0.058726 0.436141 -0.135 0.89289 ## fitted(MEpoisLMR) -8.856022 1.670191 -5.302 0.000000114 *** ## Zero hurdle model coefficients (binomial with logit link): ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -1.013658 0.570592 -1.777 0.075650 . ## IICA_High1 -0.091317 0.177363 -0.515 0.606652 ## UBN -0.011792 0.004690 -2.514 0.011928 * ## Per_Rur -0.005190 0.003982 -1.303 0.192473 ## Cobertura 2.283308 0.624231 3.658 0.000254 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Number of iterations in BFGS optimization: 12 ## Log-likelihood: -610 on 11 Df pR2(mod.hurdleLMR) ## fitting null model for pseudo-r2 ## llh llhNull G2 McFadden r2ML r2CU ## -610.0288758 -1369.2239672 1518.3901828 0.5544711 0.7409880 0.8120241 moran.test(resid_Pois_Hurdle, mat[[which.max(aux)]], alternative=&quot;two.sided&quot;) ## ## Moran I test under randomisation ## ## data: resid_Pois_Hurdle ## weights: mat[[which.max(aux)]] ## ## Moran I statistic standard deviate = 1.4546, p-value = 0.1458 ## alternative hypothesis: two.sided ## sample estimates: ## Moran I statistic Expectation Variance ## 0.027522708 -0.000890472 0.000381564 Rurality and health coverage are not statistically significant for counto model. So, those predictors are excluded of the spatial filtering and model. MEpoisLMR &lt;- spatialreg::ME(Ndeaths ~ IICA_High+UBN+offset(log(EsperadosDeNCancer)),data=muncol,family=&quot;poisson&quot;,listw=knn4_nb_b, alpha=0.02, verbose=TRUE) ## eV[,11], I: 0.01071212 ZI: NA, pr(ZI): 0.32 MoranEigenVLMR=data.frame(fitted(MEpoisLMR)) #summary(MoranEigenVLMR) mod.hurdleLMR &lt;- hurdle(Ndeaths ~IICA_High+UBN+fitted(MEpoisLMR)+offset(log(EsperadosDeNCancer))|UBN+Cobertura+offset(log(EsperadosDeNCancer)),data = muncol,dist = &quot;poisson&quot;, zero.dist = &quot;binomial&quot;) summary(mod.hurdleLMR) ## ## Call: ## hurdle(formula = Ndeaths ~ IICA_High + UBN + fitted(MEpoisLMR) + offset(log(EsperadosDeNCancer)) | UBN + Cobertura + ## offset(log(EsperadosDeNCancer)), data = muncol, dist = &quot;poisson&quot;, zero.dist = &quot;binomial&quot;) ## ## Pearson residuals: ## Min 1Q Median 3Q Max ## -1.5905 -0.4184 -0.2973 -0.1823 7.3265 ## ## Count model coefficients (truncated poisson with log link): ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 0.355460 0.097724 3.637 0.000275 *** ## IICA_High1 0.274468 0.100011 2.744 0.006062 ** ## UBN -0.013803 0.003796 -3.636 0.000277 *** ## fitted(MEpoisLMR) -9.134355 1.617421 -5.647 0.0000000163 *** ## Zero hurdle model coefficients (binomial with logit link): ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -1.279352 0.535993 -2.387 0.016992 * ## UBN -0.014391 0.004288 -3.356 0.000789 *** ## Cobertura 2.354642 0.616661 3.818 0.000134 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Number of iterations in BFGS optimization: 11 ## Log-likelihood: -611.3 on 7 Df pR2(mod.hurdleLMR) ## fitting null model for pseudo-r2 ## llh llhNull G2 McFadden r2ML r2CU ## -611.2637930 -1369.2239672 1515.9203483 0.5535692 0.7404182 0.8113997 moran.test(resid_Pois_Hurdle, mat[[which.max(aux)]], alternative=&quot;two.sided&quot;) ## ## Moran I test under randomisation ## ## data: resid_Pois_Hurdle ## weights: mat[[which.max(aux)]] ## ## Moran I statistic standard deviate = 1.4546, p-value = 0.1458 ## alternative hypothesis: two.sided ## sample estimates: ## Moran I statistic Expectation Variance ## 0.027522708 -0.000890472 0.000381564 Now, Poisson-Hurdle model residuals are not significant spatially autocorrelated. The LMR’s positive values depend only on the Index of armed conflict (IICA) and on the unsatisfied basic needs index (UBN) and LMR’s zero values depend on the UBN and health coverage. Note that the model shows good performance, according to pseudo R2 and the comparison between observed and predicted frequencies. mf &lt;- model.frame(mod.hurdleLMR) y &lt;- model.response(mf) w &lt;- model.weights(mf) if(is.null(w)) w &lt;- rep(1, NROW(y)) max0 &lt;- 20L obs &lt;- as.vector(xtabs(w ~ factor(y, levels = 0L:max0))) exp &lt;- colSums(predict(mod.hurdleLMR, type = &quot;prob&quot;, at = 0L:max0) * w) fitted_vs_observed &lt;- data.frame(Expected = exp, Observed = obs) data &lt;- reshape2::melt(fitted_vs_observed) ## No id variables; using all as measure variables data &lt;- data.frame(data, x = 0:20) data1 &lt;- data[1:21, ] data2 &lt;- data[22:42, ] pMortality &lt;- ggplot() + geom_line(data1, mapping = aes(x = x, y = value, group = variable , color = variable)) + geom_point(data1, mapping = aes(x = x, y = value, group = variable, color = variable)) + geom_col(data2, mapping = aes(x = x, y = value, group = variable), alpha = 0.7) + theme_light() + labs(x = &quot;Number of deaths&quot;, y = &quot;Frecuencies&quot;) pMortality 2.2 Incidence Spatial modeling of incidence and mortality childhood leukemia based on Colombian armed conflict and poverty for children born during the years 2002-2013 2.2.1 Packages Incidence rm(list=ls()) require(rgdal) require(pscl) require(sf) require(spdep) require(spatialreg) #test.W, scores.listw require(stringr) require(performance) require(AER) require(ggplot2) require(vcdExtra) 2.2.2 Code Incidence Reading the shapefile of 1124 Colombian municipalities, defining the Coordinate Reference System and centroid and building some variables #Reading the shapefile of 1124 Colombian municipalities muncol &lt;- rgdal::readOGR(dsn=&quot;Armed_Conflict_Vs_Leukemia/muncol.shp&quot;) ## OGR data source with driver: ESRI Shapefile ## Source: &quot;/home/jncc/Documents/Notebooks/Monitorias/Bookdown/Cuadernos/Armed_Conflict_Vs_Leukemia/muncol.shp&quot;, layer: &quot;muncol&quot; ## with 1124 features ## It has 17 fields muncol=spTransform(muncol,CRS(&quot;+init=epsg:21897&quot;)) (l &lt;- length(muncol)) ## [1] 1124 #Representative coordinate (centroid) xy0=data.frame(x=muncol$x,y=muncol$y) coordinates(xy0) &lt;- c(&#39;x&#39;,&#39;y&#39;) proj4string(xy0) &lt;- CRS(&quot;+init=epsg:4326&quot;) xy0=spTransform(xy0,CRS(&quot;+init=epsg:21897&quot;)) ###Loops for avoiding NA r &lt;- sum(muncol$NCases)/sum(muncol$NPop) for (i in 1:l){ if(muncol$NPop[i]==0){ muncol$EsperadosNCancer[i] &lt;- 1 } else{ muncol$EsperadosNCancer[i] &lt;- muncol$NPop[i]*r } } muncol$IICA_Cat=muncol$IICA_Ca muncol$IICA_Cat=str_replace_all(muncol$IICA_Cat,&quot;Bajo&quot;, &quot;Low&quot;) muncol$IICA_Cat=str_replace_all(muncol$IICA_Cat,&quot;Medio&quot;, &quot;Medium&quot;) muncol$IICA_CatLow=ifelse(muncol$IICA_Cat==&quot;Low&quot;,1,0) muncol$IICA_CatMed=ifelse(muncol$IICA_Cat==&quot;Medium&quot;,1,0) muncol$IICA_High=as.character(1-(muncol$IICA_CatLow+muncol$IICA_CatMed)) muncol$UBN=muncol$NBI Modeling leukemia Incidence Rate (LR) in terms of Colombian armed conflict index, poverty and rurality. First, the usual Poisson regression model with incidence rate as response variable is estimated. glmbaseLR&lt;-glm(NCases ~IICA_High+UBN+Per_Rur+offset(log(EsperadosNCancer)), family = poisson,data = muncol) anova(glmbaseLR) ## Analysis of Deviance Table ## ## Model: poisson, link: log ## ## Response: NCases ## ## Terms added sequentially (first to last) ## ## ## Df Deviance Resid. Df Resid. Dev ## NULL 1123 2524.9 ## IICA_High 1 0.75 1122 2524.1 ## UBN 1 328.90 1121 2195.2 ## Per_Rur 1 0.11 1120 2195.1 summary(glmbaseLR) ## ## Call: ## glm(formula = NCases ~ IICA_High + UBN + Per_Rur + offset(log(EsperadosNCancer)), ## family = poisson, data = muncol) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -5.1779 -1.1632 -0.5270 0.6082 7.7193 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 0.3226036 0.0276280 11.677 &lt; 0.0000000000000002 *** ## IICA_High1 0.0818208 0.0294297 2.780 0.00543 ** ## UBN -0.0123797 0.0010425 -11.875 &lt; 0.0000000000000002 *** ## Per_Rur -0.0002510 0.0007692 -0.326 0.74419 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for poisson family taken to be 1) ## ## Null deviance: 2524.9 on 1123 degrees of freedom ## Residual deviance: 2195.1 on 1120 degrees of freedom ## AIC: 4174.2 ## ## Number of Fisher Scoring iterations: 5 muncol$residLR=residuals(glmbaseLR) Rurality is not statistically significant in this first auxiliar model. However, we maintain this variable in the rest of the analysis and review its significance in the final model. Checking excess zeros by comparison between the number of zeros predicted by the model with the observed number of zeros. Also checking overdispersion. mu_LR &lt;- predict(glmbaseLR, type = &quot;response&quot;) # predict expected mean count expLR &lt;- sum(dpois(x = 0, lambda = mu_LR)) # sum the probabilities of a zero count for each mean round(expLR) #predicted number of zeros ## [1] 382 sum(muncol$NCases &lt; 1) #observed number of zeros ## [1] 443 zero.test(muncol$NCases) #score test (van den Broek, 1995) ## Score test for zero inflation ## ## Chi-square = 12268.7129 ## df = 1 ## pvalue: &lt; 0.000000000000000222 ##Checking overdispersion dispersiontest(glmbaseLR) #Cameron &amp; Trivedi (1990) ## ## Overdispersion test ## ## data: glmbaseLR ## z = 4.1887, p-value = 0.00001403 ## alternative hypothesis: true dispersion is greater than 1 ## sample estimates: ## dispersion ## 2.309041 check_overdispersion(glmbaseLR) #Gelman and Hill (2007) ## # Overdispersion test ## ## dispersion ratio = 2.431 ## Pearson&#39;s Chi-Squared = 2722.353 ## p-value = &lt; 0.001 ## Overdispersion detected. The observed frequency of zeroes in data exceeds the predicted in the Leukemia incidence rate (LR) model. Also, overdispersion is detected. Now, to validate the independence assumption, first, it is necessary to define spatial weighting possible matrices. rook_nb_b=nb2listw(poly2nb(muncol,queen=FALSE), style=&quot;B&quot;,zero.policy = TRUE) rook_nb_w=nb2listw(poly2nb(muncol,queen=FALSE), style=&quot;W&quot;,zero.policy = TRUE) queen_nb_b=nb2listw(poly2nb(muncol,queen=TRUE), style=&quot;B&quot;,zero.policy = TRUE) queen_nb_w=nb2listw(poly2nb(muncol,queen=TRUE), style=&quot;W&quot;,zero.policy = TRUE) #Graphs neighbours trinb=tri2nb(xy0) options(warn = -1) tri_nb_b=nb2listw(tri2nb(xy0), style=&quot;B&quot;,zero.policy = TRUE) tri_nb_w=nb2listw(tri2nb(xy0), style=&quot;W&quot;,zero.policy = TRUE) soi_nb_b=nb2listw(graph2nb(soi.graph(trinb,xy0)), style=&quot;B&quot;,zero.policy = TRUE) soi_nb_w=nb2listw(graph2nb(soi.graph(trinb,xy0)), style=&quot;W&quot;,zero.policy = TRUE) relative_nb_b=nb2listw(graph2nb(relativeneigh(xy0), sym=TRUE), style=&quot;B&quot;,zero.policy = TRUE) relative_nb_w=nb2listw(graph2nb(relativeneigh(xy0), sym=TRUE), style=&quot;W&quot;,zero.policy = TRUE) gabriel_nb_b=nb2listw(graph2nb(gabrielneigh(xy0), sym=TRUE), style=&quot;B&quot;,zero.policy = TRUE) gabriel_nb_w=nb2listw(graph2nb(gabrielneigh(xy0), sym=TRUE), style=&quot;W&quot;,zero.policy = TRUE) #Distance neighbours knn1_nb_b=nb2listw(knn2nb(knearneigh(xy0, k = 1)), style=&quot;B&quot;,zero.policy = TRUE) knn1_nb_w=nb2listw(knn2nb(knearneigh(xy0, k = 1)), style=&quot;W&quot;,zero.policy = TRUE) knn2_nb_b=nb2listw(knn2nb(knearneigh(xy0, k = 2)), style=&quot;B&quot;,zero.policy = TRUE) knn2_nb_w=nb2listw(knn2nb(knearneigh(xy0, k = 2)), style=&quot;W&quot;,zero.policy = TRUE) knn3_nb_b=nb2listw(knn2nb(knearneigh(xy0, k = 3)), style=&quot;B&quot;,zero.policy = TRUE) knn3_nb_w=nb2listw(knn2nb(knearneigh(xy0, k = 3)), style=&quot;W&quot;,zero.policy = TRUE) knn4_nb_b=nb2listw(knn2nb(knearneigh(xy0, k = 4)), style=&quot;B&quot;,zero.policy = TRUE) knn4_nb_w=nb2listw(knn2nb(knearneigh(xy0, k = 4)), style=&quot;W&quot;,zero.policy = TRUE) knn6_nb_b=nb2listw(knn2nb(knearneigh(xy0, k = 6)), style=&quot;B&quot;,zero.policy = TRUE) knn6_nb_w=nb2listw(knn2nb(knearneigh(xy0, k = 6)), style=&quot;W&quot;,zero.policy = TRUE) mat=list(rook_nb_b,rook_nb_w, queen_nb_b,queen_nb_w, tri_nb_b,tri_nb_w, soi_nb_b,soi_nb_w, gabriel_nb_b,gabriel_nb_w, relative_nb_b,relative_nb_w, knn1_nb_b,knn1_nb_w, knn2_nb_b,knn2_nb_w, knn3_nb_b,knn3_nb_w, knn4_nb_b,knn4_nb_w, knn6_nb_b,knn6_nb_w) Testing spatial autocorrelation using Moran index test based on weighting matrices built in the last step. Note that with all weighting matrices we obtain a significant spatial autocorrelation. aux=numeric(0) options(warn = -1) { for(i in 1:length(mat)) aux[i]=moran.test(muncol$residLR,mat[[i]],alternative=&quot;two.sided&quot;)$&quot;p&quot; } aux ## [1] 0.0000000017764454223 0.0000000000163053411 0.0000000011162954779 0.0000000000340919650 0.0000000002619438209 ## [6] 0.0000000000198490005 0.0000000000280007352 0.0000000000264847296 0.0000000000707310275 0.0000000000040680047 ## [11] 0.0000000013453360945 0.0000000058676552459 0.0006342820038119230 0.0006342820038119230 0.0000000053378560647 ## [16] 0.0000000053378560647 0.0000000000046536598 0.0000000000046536598 0.0000000000002138542 0.0000000000002138542 ## [21] 0.0000000000005932765 0.0000000000005932765 moran.test(muncol$residLR, mat[[which.max(aux)]], alternative=&quot;two.sided&quot;) ## ## Moran I test under randomisation ## ## data: muncol$residLR ## weights: mat[[which.max(aux)]] ## ## Moran I statistic standard deviate = 3.4165, p-value = 0.0006343 ## alternative hypothesis: two.sided ## sample estimates: ## Moran I statistic Expectation Variance ## 0.123653792 -0.000890472 0.001328865 First, Poisson Hurdle model is estimated without consider spatial autocorrelation. mod.hurdleLR &lt;- hurdle(NCases ~IICA_High+UBN+Per_Rur+offset(log(EsperadosNCancer))|IICA_High+UBN+Per_Rur+offset(log(EsperadosNCancer)),data = muncol,dist = &quot;poisson&quot;, zero.dist = &quot;binomial&quot;) resid_Pois_Hurdle=residuals(mod.hurdleLR,&quot;response&quot;) summary(mod.hurdleLR) ## ## Call: ## hurdle(formula = NCases ~ IICA_High + UBN + Per_Rur + offset(log(EsperadosNCancer)) | IICA_High + UBN + Per_Rur + ## offset(log(EsperadosNCancer)), data = muncol, dist = &quot;poisson&quot;, zero.dist = &quot;binomial&quot;) ## ## Pearson residuals: ## Min 1Q Median 3Q Max ## -3.6935 -0.7943 -0.3775 0.6266 17.7799 ## ## Count model coefficients (truncated poisson with log link): ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 0.3151943 0.0289252 10.897 &lt;0.0000000000000002 *** ## IICA_High1 0.0769858 0.0309613 2.487 0.0129 * ## UBN -0.0123171 0.0011548 -10.666 &lt;0.0000000000000002 *** ## Per_Rur 0.0020604 0.0008876 2.321 0.0203 * ## Zero hurdle model coefficients (binomial with logit link): ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 1.001514 0.249402 4.016 0.0000593 *** ## IICA_High1 0.072259 0.137921 0.524 0.600 ## UBN -0.013830 0.003541 -3.906 0.0000939 *** ## Per_Rur -0.004660 0.003364 -1.385 0.166 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Number of iterations in BFGS optimization: 9 ## Log-likelihood: -2051 on 8 Df pR2(mod.hurdleLR) ## fitting null model for pseudo-r2 ## llh llhNull G2 McFadden r2ML r2CU ## -2051.4697559 -9229.3509481 14355.7623845 0.7777233 0.9999972 0.9999972 moran.test(resid_Pois_Hurdle, mat[[which.max(aux)]], alternative=&quot;two.sided&quot;) ## ## Moran I test under randomisation ## ## data: resid_Pois_Hurdle ## weights: mat[[which.max(aux)]] ## ## Moran I statistic standard deviate = 4.5053, p-value = 0.000006627 ## alternative hypothesis: two.sided ## sample estimates: ## Moran I statistic Expectation Variance ## 0.158812671 -0.000890472 0.001256531 Thus, residuals are significantly spatially autocorrelated. So, we are going tu use spatial filtering. Below we find Moran Eigenvectors. MEpoisLR &lt;- spatialreg::ME(NCases ~ IICA_High+UBN+Per_Rur+offset(log(EsperadosNCancer)),data=muncol,family=&quot;poisson&quot;,listw=mat[[3]], alpha=0.02, verbose=TRUE) ## eV[,29], I: 0.01179903 ZI: NA, pr(ZI): 0.18 MoranEigenVLR=data.frame(fitted(MEpoisLR)) Now, we used Poisson Hurdle model to manage the overdispersion due to zero excess and Moran eigenfunctions are included as additional explanatory variables, so that spatial autocorrelation is considered. mod.hurdleLR &lt;- hurdle(NCases ~IICA_High+UBN+Per_Rur+fitted(MEpoisLR)+offset(log(EsperadosNCancer))|Per_Rur+offset(log(EsperadosNCancer)),data = muncol,dist = &quot;poisson&quot;, zero.dist = &quot;binomial&quot;) resid_Pois_Hurdle=residuals(mod.hurdleLR,&quot;response&quot;) moran.test(resid_Pois_Hurdle, mat[[3]], alternative=&quot;two.sided&quot;) ## ## Moran I test under randomisation ## ## data: resid_Pois_Hurdle ## weights: mat[[3]] ## ## Moran I statistic standard deviate = 1.0424, p-value = 0.2972 ## alternative hypothesis: two.sided ## sample estimates: ## Moran I statistic Expectation Variance ## 0.0162024286 -0.0008904720 0.0002689009 summary(mod.hurdleLR) ## ## Call: ## hurdle(formula = NCases ~ IICA_High + UBN + Per_Rur + fitted(MEpoisLR) + offset(log(EsperadosNCancer)) | Per_Rur + ## offset(log(EsperadosNCancer)), data = muncol, dist = &quot;poisson&quot;, zero.dist = &quot;binomial&quot;) ## ## Pearson residuals: ## Min 1Q Median 3Q Max ## -3.2263 -0.7927 -0.3875 0.6339 17.8272 ## ## Count model coefficients (truncated poisson with log link): ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 0.2275843 0.0328678 6.924 0.00000000000438 *** ## IICA_High1 0.1568024 0.0342051 4.584 0.00000455776768 *** ## UBN -0.0113328 0.0011644 -9.733 &lt; 0.0000000000000002 *** ## Per_Rur 0.0016899 0.0008965 1.885 0.0594 . ## fitted(MEpoisLR) 2.6540637 0.4767638 5.567 0.00000002594128 *** ## Zero hurdle model coefficients (binomial with logit link): ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 0.646903 0.213106 3.036 0.0024 ** ## Per_Rur -0.008731 0.003237 -2.697 0.0070 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Number of iterations in BFGS optimization: 10 ## Log-likelihood: -2044 on 7 Df pR2(mod.hurdleLR) ## fitting null model for pseudo-r2 ## llh llhNull G2 McFadden r2ML r2CU ## -2043.6785123 -9229.3509481 14371.3448717 0.7785675 0.9999972 0.9999973 Rurality is not statistically significant to explain the Leukemia incidence rate. The only predictor statistically significant for zeroes model is rurality. In addition, the Spatial filtering results are the same without this variable. MEpoisLR &lt;- spatialreg::ME(NCases ~ IICA_High+UBN+offset(log(EsperadosNCancer)),data=muncol,family=&quot;poisson&quot;,listw=mat[[3]], alpha=0.02, verbose=TRUE) ## eV[,29], I: 0.01112525 ZI: NA, pr(ZI): 0.2 MoranEigenVLR=data.frame(fitted(MEpoisLR)) mod.hurdleLR &lt;- hurdle(NCases ~IICA_High+UBN+fitted(MEpoisLR)+offset(log(EsperadosNCancer))|Per_Rur+offset(log(EsperadosNCancer)),data = muncol,dist = &quot;poisson&quot;, zero.dist = &quot;binomial&quot;) resid_Pois_Hurdle=residuals(mod.hurdleLR,&quot;response&quot;) moran.test(resid_Pois_Hurdle, mat[[3]], alternative=&quot;two.sided&quot;) ## ## Moran I test under randomisation ## ## data: resid_Pois_Hurdle ## weights: mat[[3]] ## ## Moran I statistic standard deviate = 1.2484, p-value = 0.2119 ## alternative hypothesis: two.sided ## sample estimates: ## Moran I statistic Expectation Variance ## 0.0194478991 -0.0008904720 0.0002654261 summary(mod.hurdleLR) ## ## Call: ## hurdle(formula = NCases ~ IICA_High + UBN + fitted(MEpoisLR) + offset(log(EsperadosNCancer)) | Per_Rur + offset(log(EsperadosNCancer)), ## data = muncol, dist = &quot;poisson&quot;, zero.dist = &quot;binomial&quot;) ## ## Pearson residuals: ## Min 1Q Median 3Q Max ## -3.3173 -0.7976 -0.3786 0.6607 18.2757 ## ## Count model coefficients (truncated poisson with log link): ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 0.2143974 0.0321264 6.674 0.000000000025 *** ## IICA_High1 0.1700350 0.0335266 5.072 0.000000394376 *** ## UBN -0.0097928 0.0008191 -11.955 &lt; 0.0000000000000002 *** ## fitted(MEpoisLR) 2.7262303 0.4759204 5.728 0.000000010142 *** ## Zero hurdle model coefficients (binomial with logit link): ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 0.646903 0.213106 3.036 0.0024 ** ## Per_Rur -0.008731 0.003237 -2.697 0.0070 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Number of iterations in BFGS optimization: 9 ## Log-likelihood: -2045 on 6 Df pR2(mod.hurdleLR) ## fitting null model for pseudo-r2 ## llh llhNull G2 McFadden r2ML r2CU ## -2045.4283395 -9229.3509481 14367.8452173 0.7783779 0.9999972 0.9999973 Hence, Poisson-Hurdle model residuals are not significant spatially autocorrelated. The LR’s positive values depend only on the Index of armed conflict (IICA) and on the unsatisfied basic needs index (UBN) and its zero values depend on the rurality. Note that the model shows good performance, according to pseudo R2 and the comparison between observed and predicted frequencies. mf &lt;- model.frame(mod.hurdleLR) y &lt;- model.response(mf) w &lt;- model.weights(mf) if(is.null(w)) w &lt;- rep(1, NROW(y)) max0 &lt;- 20L obs &lt;- as.vector(xtabs(w ~ factor(y, levels = 0L:max0))) exp &lt;- colSums(predict(mod.hurdleLR, type = &quot;prob&quot;, at = 0L:max0) * w) fitted_vs_observed &lt;- data.frame(Expected = exp, Observed = obs) data &lt;- reshape2::melt(fitted_vs_observed) ## No id variables; using all as measure variables data &lt;- data.frame(data, x = 0:20) data1 &lt;- data[1:21, ] data2 &lt;- data[22:42, ] pl1 &lt;- ggplot() + geom_line(data1, mapping = aes(x = x, y = value, group = variable , color = variable)) + geom_point(data1, mapping = aes(x = x, y = value, group = variable, color = variable)) + geom_col(data2, mapping = aes(x = x, y = value, group = variable), alpha = 0.7) + theme_light() + labs(x = &quot;Number of cases&quot;, y = &quot;Frecuencies&quot;) pl1 "],["estudio-de-mercadeo-espacial-bac.html", "Chapter 3 Estudio de Mercadeo Espacial BAC 3.1 Paquetes 3.2 Lectura de Datos 3.3 Matriz de vecindades 3.4 Mapa de valores observados 3.5 Pruebas de Autocorrelación 3.6 Mapas 3.7 Resumen de modelos 3.8 Calculo de varibles significativas 3.9 Mapa Estimado", " Chapter 3 Estudio de Mercadeo Espacial BAC 3.1 Paquetes rm(list=ls()) library(openxlsx) library(dplyr) library(rgdal) library(maptools) library(GISTools) library(spdep) library(readr) library(car) library(readxl) library(psych) library(rgdal) library(FactoClass) library(spdep) require(&quot;GWmodel&quot;) library(&quot;mapsRinteractive&quot;) options(scipen = 999) 3.2 Lectura de Datos # Lectura de Datos BASE &lt;- read_excel(&quot;Trabajo Grado/BASE.xlsx&quot;) # Lectura del Shape de Colombia por Departamentos Colombia = readOGR(dsn = &quot;Trabajo Grado/Geodatabase Colombia&quot;, layer = &quot;departamentos&quot;) ## OGR data source with driver: ESRI Shapefile ## Source: &quot;/home/jncc/Documents/Notebooks/Monitorias/Bookdown/Cuadernos/Trabajo Grado/Geodatabase Colombia&quot;, layer: &quot;departamentos&quot; ## with 33 features ## It has 6 fields ## Integer64 fields read as strings: AñO_CREAC 3.2.1 Cruce de información y arreglo de coordenadas #Cruce de información con el shape cargado Insumo = merge(Colombia, BASE, by.x=&quot;COD_DANE&quot;, by.y=&quot;Cod&quot;) Insumo = subset(Insumo[c(1:31,33),]) # Conversión a Coordenadas UTM Crs.geo = CRS(&quot;+proj=tmerc +lat_0=4.599047222222222 +lon_0=-74.08091666666667 +k=1 +x_0=1000000 +y_0=1000000 +ellps=intl +towgs84=307,304,-318,0,0,0,0 +units=m +no_defs&quot;) proj4string(Insumo) &lt;- Crs.geo Insumo.utm = spTransform(Insumo, CRS(&quot;+init=epsg:3724 +units=km&quot;)) 3.3 Matriz de vecindades #--- # MATRIZ DE VECINDADES (W) #--- ## Centroides de las Áreas Centros = getSpPPolygonsLabptSlots(Insumo.utm) Centroids &lt;- SpatialPointsDataFrame(coords = Centros, data=Insumo.utm@data, proj4string=CRS(&quot;+init=epsg:3724 +units=km&quot;)) # Matriz de Distancias entre los Centriodes Wdist = dist(Centros, up=T) # Matriz W de vecindades library(pgirmess) library(HistogramTools) library(strucchange) library(spdep) Insumo.nb = poly2nb(Insumo.utm, queen=T) #n &lt;- max(sapply(Insumo.nb, length)) #ll &lt;- lapply(Insumo.nb, function(X) { # c(as.numeric(X), rep(0, times = n - length(X))) #}) #out &lt;- do.call(cbind, ll) #Departamentos&lt;-Insumo$Departamento #MatW&lt;-matrix(NA,32,32) #for (i in 1:8) { # for (j in 1:32) { # if (out[i,j]!=0) { # MatW[out[i,j],j]&lt;-1 # } else{MatW[out[i,j],j]&lt;-0} # } #} #for (i in 1:32) { # for (j in 1:32) { # if (is.na(MatW[i,j])) { # MatW[i,j]&lt;-0 # } # } #} #colnames(MatW)&lt;-Departamentos #rownames(MatW)&lt;-Departamentos #MatW1&lt;-MatW[,1:16] #MatW2&lt;-MatW[,17:32] # Martiz W (Estilos) Insumo.lw = nb2listw(Insumo.nb) Insumo.lwb = nb2listw(Insumo.nb, style=&quot;B&quot;) Insumo.lwc = nb2listw(Insumo.nb, style=&quot;C&quot;) Insumo.lwu = nb2listw(Insumo.nb, style=&quot;U&quot;) Insumo.lww = nb2listw(Insumo.nb, style=&quot;W&quot;) 3.4 Mapa de valores observados # Mapa de Valores Observados #dev.new() #windows() choropleth(Insumo, Insumo$CAP_BAC) shad = auto.shading(Insumo$CAP_BAC, n=5, cols=(brewer.pal(5,&quot;Reds&quot;)), cutter = quantileCuts) choro.legend(1555874,535165.5, shad, fmt=&quot;%1.1f&quot;, title = &quot;Valores Locales&quot;, cex=0.7, under = &quot;Menos de&quot;, between = &quot;a&quot;, over = &quot;Mas de&quot;) title(&quot;Valores Observados para las captaciones del banco agrario en Colombia, cuarto trimestre 2020&quot;, cex.main=1) map.scale(755874,335165.5, 250000, &quot;km&quot;, 2, 50, sfcol=&#39;brown&#39;) 3.5 Pruebas de Autocorrelación #---------------------------- # PRUEBAS DE AUTOCORRELACION #---------------------------- # Moran moran.test(Insumo$CAP_BAC, Insumo.lw) ## ## Moran I test under randomisation ## ## data: Insumo$CAP_BAC ## weights: Insumo.lw ## ## Moran I statistic standard deviate = 2.0024, p-value = 0.02262 ## alternative hypothesis: greater ## sample estimates: ## Moran I statistic Expectation Variance ## 0.153081266 -0.032258065 0.008566935 # Dispersograma de Moran #dev.new() #windows() moran.plot(Insumo$CAP_BAC, Insumo.lw, labels=as.character(Insumo$Departamento), xlab=&quot;Captaciones BAC&quot;, ylab=&quot;Captaciones BAC rezagado&quot;, las=1, pch=16, cex=0.5) legend(&quot;bottomright&quot;, legend=c(&quot;I de Moran: 0.1530&quot;, &quot;Valor P: 0.02262&quot;), cex=1,bg=&#39;lightgreen&#39;) title(&quot;Dispersograma de Moran para las captaciones del banco agrario en los Departamentos de Colombia, cuarto trimestre 2020&quot;, cex.main=1) # Local G nearng = dnearneigh(coordinates(Insumo.utm), 0, 550) Insumo.lw.g = nb2listw(nearng, style=&quot;B&quot;) localG = localG(Insumo$CAP_BAC, Insumo.lw.g); localG ## [1] 1.66525050 0.02608278 1.33032949 1.15892050 1.85852161 0.68445519 1.49486468 0.10163662 1.64717068 1.32714028 ## [11] 2.53361281 2.21899396 -0.71311540 0.50952811 1.48899277 0.81676480 0.98434717 2.09087184 2.08725553 1.05493906 ## [21] 1.32486118 2.09147517 2.16305539 1.89323276 1.52155929 0.84992902 -1.19798594 -1.33847805 0.29701426 -1.60300117 ## [31] 1.67015910 1.96543367 ## attr(,&quot;cluster&quot;) ## [1] High Low Low High Low Low High Low Low High Low High Low Low Low High High Low Low High Low High High Low Low ## [26] Low Low Low Low Low Low High ## Levels: Low High ## attr(,&quot;gstari&quot;) ## [1] FALSE ## attr(,&quot;call&quot;) ## localG(x = Insumo$CAP_BAC, listw = Insumo.lw.g) ## attr(,&quot;class&quot;) ## [1] &quot;localG&quot; # Simulaci?n montecarlo sim.G = matrix(0,1000,32) for(i in 1:1000) sim.G[i,] = localG(sample(Insumo$CAP_BAC),Insumo.lw.g) mc.pvalor.G = (colSums(sweep(sim.G,2,localG,&quot;&gt;=&quot;))+1)/(nrow(sim.G)+1) mc.pvalor.G ## [1] 0.010989011 0.441558442 0.090909091 0.115884116 0.000999001 0.268731269 0.077922078 0.481518482 0.032967033 0.047952048 ## [11] 0.000999001 0.005994006 0.718281718 0.315684316 0.026973027 0.226773227 0.183816184 0.000999001 0.000999001 0.143856144 ## [21] 0.099900100 0.000999001 0.002997003 0.024975025 0.046953047 0.221778222 0.973026973 0.963036963 0.433566434 0.989010989 ## [31] 0.057942058 0.000999001 3.6 Mapas # Mapas par(mfrow=c(1,2), mar=c(1,1,8,1)/2) shadeg = auto.shading(localG, n=5, cols=(brewer.pal(5,&quot;Purples&quot;)), cutter=quantileCuts) #dev.new() #windows() choropleth(Insumo, localG, shading=shadeg) choro.legend(1555874,535165.5, shadeg, fmt=&quot;%1.2f&quot;, title = &quot;G&quot;, cex=0.7, under = &quot;Menos de&quot;, between = &quot;a&quot;, over = &quot;Mas de&quot;) title(&quot;G Getis Ord Local para las captaciones del banco agrario en Colombia, cuarto trimestre 2020&quot;, cex.main=1) map.scale(755874,335165.5, 250000, &quot;km&quot;, 2, 50, sfcol=&#39;brown&#39;) # Mapa de P-values #dev.new() #windows() shadegp = shading(c(0.01,0.05,0.1), cols = (brewer.pal(4,&quot;Spectral&quot;))) choropleth(Insumo, mc.pvalor.G, shading=shadegp) choro.legend(1555874,535165.5, shadegp, fmt=&quot;%1.2f&quot;, title = &quot;P-valor de G&quot;, cex=0.7, under = &quot;Menos de&quot;, between = &quot;a&quot;, over = &quot;Mas de&quot;) title(&quot;P- Valor de G Getis Ord Local para las captaciones del banco agrario en Colombia, cuarto trimestre 2020&quot;, cex.main=1) map.scale(755874,335165.5, 250000, &quot;km&quot;, 2, 50, sfcol=&#39;brown&#39;) ##Modelos SDEM, SDM, Manski, SARAR ####Modelos SDEM, SDM, Manski, SARAR######## #reg.eq1=CAP_BAC ~ PIB + NBI + CAP_BOG + CAP_BC + CAP_OCC + CAP_CS + Población + IPM reg.eq1=CAP_BAC ~ PIB + NBI + CAP_BOG+CAP_BC + CAP_OCC + CAP_CS+ Población reg1=lm(reg.eq1,data=Insumo) #OLS y=XB+e, reg2=lmSLX(reg.eq1,data=Insumo, Insumo.lw) #SLX y=XB+WxT+e reg3=lagsarlm(reg.eq1,data= Insumo, Insumo.lw) #Lag Y y=XB+WxT+u, u=LWu+e reg4=errorsarlm(reg.eq1,data=Insumo, Insumo.lw) #Spatial Error y=pWy+XB+e reg5=errorsarlm(reg.eq1, data=Insumo, Insumo.lw, etype=&quot;emixed&quot;) #SDEM Spatial Durbin Error Model y=XB+WxT+u, u=LWu+e reg6=lagsarlm(reg.eq1, data=Insumo,Insumo.lw, type=&quot;mixed&quot;) #SDM Spatial Durbin Model (add lag X to SAR) y=pWy+XB+WXT+e reg7=sacsarlm(reg.eq1,data=Insumo, Insumo.lw, type=&quot;sacmixed&quot;) #Manski Model: y=pWy+XB+WXT+u, u=LWu+e (no recomendado) reg8=sacsarlm(reg.eq1,data=Insumo,Insumo.lw, type=&quot;sac&quot;) #SARAR o Kelejian-Prucha, Cliff-Ord, o SAC If all T=0,y=pWy+XB+u, u=LWu+e 3.7 Resumen de modelos #Resumen de modelos s=summary s(reg1)#OLS ## ## Call: ## lm(formula = reg.eq1, data = Insumo) ## ## Residuals: ## Min 1Q Median 3Q Max ## -276.51 -65.60 -7.76 46.60 396.20 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 148.21380364 79.80068638 1.857 0.0756 . ## PIB 0.00389642 0.00328986 1.184 0.2479 ## NBI -1.28539812 1.73982368 -0.739 0.4672 ## CAP_BOG -0.06643826 0.05411306 -1.228 0.2314 ## CAP_BC 0.00397406 0.00607852 0.654 0.5195 ## CAP_OCC -0.04340185 0.02170799 -1.999 0.0570 . ## CAP_CS 0.47283237 0.31370238 1.507 0.1448 ## Población 0.00000137 0.00006700 0.020 0.9839 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 141.6 on 24 degrees of freedom ## Multiple R-squared: 0.8807, Adjusted R-squared: 0.8459 ## F-statistic: 25.31 on 7 and 24 DF, p-value: 0.000000001309 s(reg2)#SLX ## ## Call: ## lm(formula = formula(paste(&quot;y ~ &quot;, paste(colnames(x)[-1], collapse = &quot;+&quot;))), ## data = as.data.frame(x), weights = weights) ## ## Residuals: ## Min 1Q Median 3Q Max ## -201.00 -74.99 -0.51 34.55 342.00 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 392.97159157 284.42668099 1.382 0.185 ## PIB 0.00429319 0.00383973 1.118 0.279 ## NBI -0.57603773 2.48213535 -0.232 0.819 ## CAP_BOG -0.00703635 0.07700761 -0.091 0.928 ## CAP_BC -0.00075536 0.01003615 -0.075 0.941 ## CAP_OCC -0.05372016 0.03418522 -1.571 0.135 ## CAP_CS 0.12199794 0.43670734 0.279 0.783 ## Población 0.00004753 0.00012149 0.391 0.701 ## lag.PIB 0.00317318 0.00943185 0.336 0.741 ## lag.NBI -6.81433196 5.99552430 -1.137 0.271 ## lag.CAP_BOG -0.06868663 0.18842513 -0.365 0.720 ## lag.CAP_BC 0.00684589 0.01472675 0.465 0.648 ## lag.CAP_OCC -0.00984285 0.05447122 -0.181 0.859 ## lag.CAP_CS 0.33585267 1.09533771 0.307 0.763 ## lag.Población -0.00016927 0.00017459 -0.970 0.346 ## ## Residual standard error: 151.6 on 17 degrees of freedom ## Multiple R-squared: 0.9031, Adjusted R-squared: 0.8234 ## F-statistic: 11.32 on 14 and 17 DF, p-value: 0.000005467 s(reg3)#Lag Y ## ## Call:lagsarlm(formula = reg.eq1, data = Insumo, listw = Insumo.lw) ## ## Residuals: ## Min 1Q Median 3Q Max ## -213.859 -60.238 -17.811 42.960 393.389 ## ## Type: lag ## Coefficients: (numerical Hessian approximate standard errors) ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 77.75432883510 72.78425608641 1.0683 0.28539 ## PIB 0.00330780489 0.00158809777 2.0829 0.03726 ## NBI -0.77863477697 1.47850389439 -0.5266 0.59845 ## CAP_BOG -0.05466122014 0.04390266160 -1.2451 0.21311 ## CAP_BC 0.00533211182 0.00466511800 1.1430 0.25305 ## CAP_OCC -0.03421667889 0.01727641951 -1.9805 0.04764 ## CAP_CS 0.40699817626 0.26143664946 1.5568 0.11952 ## Población 0.00000091508 NaN NaN NaN ## ## Rho: 0.22884, LR test value: 2.096, p-value: 0.14768 ## Approximate (numerical Hessian) standard error: 0.15349 ## z-value: 1.4909, p-value: 0.13599 ## Wald statistic: 2.2227, p-value: 0.13599 ## ## Log likelihood: -198.251 for lag model ## ML residual variance (sigma squared): 13916, (sigma: 117.97) ## Number of observations: 32 ## Number of parameters estimated: 10 ## AIC: 416.5, (AIC for lm: 416.6) s(reg4)#Lag Error (SEM) ## ## Call:errorsarlm(formula = reg.eq1, data = Insumo, listw = Insumo.lw) ## ## Residuals: ## Min 1Q Median 3Q Max ## -215.7428 -56.4299 -2.2091 46.6630 425.7867 ## ## Type: error ## Coefficients: (asymptotic standard errors) ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 94.500065984 73.097738889 1.2928 0.19608 ## PIB 0.003656790 0.002619923 1.3958 0.16279 ## NBI -0.334674352 1.408551017 -0.2376 0.81219 ## CAP_BOG -0.032484043 0.049990128 -0.6498 0.51582 ## CAP_BC 0.001202333 0.005555428 0.2164 0.82866 ## CAP_OCC -0.048739699 0.019538015 -2.4946 0.01261 ## CAP_CS 0.285572487 0.287233644 0.9942 0.32012 ## Población 0.000040164 0.000066648 0.6026 0.54676 ## ## Lambda: 0.50692, LR test value: 3.8031, p-value: 0.051158 ## Approximate (numerical Hessian) standard error: 0.21495 ## z-value: 2.3584, p-value: 0.018356 ## Wald statistic: 5.5618, p-value: 0.018356 ## ## Log likelihood: -197.3975 for error model ## ML residual variance (sigma squared): 12495, (sigma: 111.78) ## Number of observations: 32 ## Number of parameters estimated: 10 ## AIC: 414.79, (AIC for lm: 416.6) s(reg5)#Durbin Error (SDEM) ## ## Call:errorsarlm(formula = reg.eq1, data = Insumo, listw = Insumo.lw, etype = &quot;emixed&quot;) ## ## Residuals: ## Min 1Q Median 3Q Max ## -199.7723 -69.8844 -2.0075 37.9235 362.9104 ## ## Type: error ## Coefficients: (asymptotic standard errors) ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 248.934472800 220.997187634 1.1264 0.25999 ## PIB 0.004499050 0.002763860 1.6278 0.10356 ## NBI -0.058410794 1.767448316 -0.0330 0.97364 ## CAP_BOG -0.026724646 0.054644416 -0.4891 0.62480 ## CAP_BC -0.000183348 0.007104434 -0.0258 0.97941 ## CAP_OCC -0.051006011 0.024157938 -2.1114 0.03474 ## CAP_CS 0.227498823 0.309055945 0.7361 0.46166 ## Población 0.000035177 0.000084525 0.4162 0.67729 ## lag.PIB 0.003069904 0.007273446 0.4221 0.67297 ## lag.NBI -4.397300877 4.370216215 -1.0062 0.31432 ## lag.CAP_BOG -0.078935307 0.133353631 -0.5919 0.55390 ## lag.CAP_BC 0.000970529 0.011031859 0.0880 0.92990 ## lag.CAP_OCC -0.013417110 0.040319111 -0.3328 0.73931 ## lag.CAP_CS 0.374124930 0.777502425 0.4812 0.63038 ## lag.Población -0.000103911 0.000125213 -0.8299 0.40661 ## ## Lambda: 0.28217, LR test value: 0.34013, p-value: 0.55976 ## Approximate (numerical Hessian) standard error: 0.45782 ## z-value: 0.61635, p-value: 0.53767 ## Wald statistic: 0.37988, p-value: 0.53767 ## ## Log likelihood: -195.7931 for error model ## ML residual variance (sigma squared): 11856, (sigma: 108.89) ## Number of observations: 32 ## Number of parameters estimated: 17 ## AIC: 425.59, (AIC for lm: 423.93) s(reg6)#Durbin (SDM) ## ## Call:lagsarlm(formula = reg.eq1, data = Insumo, listw = Insumo.lw, type = &quot;mixed&quot;) ## ## Residuals: ## Min 1Q Median 3Q Max ## -185.6170 -74.5630 -1.2308 34.6848 363.6597 ## ## Type: mixed ## Coefficients: (numerical Hessian approximate standard errors) ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 259.002885782 224.615320155 1.1531 0.24887 ## PIB 0.004292096 0.002708060 1.5849 0.11298 ## NBI -0.068020238 2.132586505 -0.0319 0.97456 ## CAP_BOG -0.013498835 0.053903632 -0.2504 0.80226 ## CAP_BC -0.000674466 0.006222482 -0.1084 0.91368 ## CAP_OCC -0.052995708 0.022652248 -2.3395 0.01931 ## CAP_CS 0.159111970 0.302853078 0.5254 0.59932 ## Población 0.000046528 0.000082317 0.5652 0.57191 ## lag.PIB 0.001006279 0.007240728 0.1390 0.88947 ## lag.NBI -5.022145755 4.587135513 -1.0948 0.27359 ## lag.CAP_BOG -0.060141055 0.131444000 -0.4575 0.64728 ## lag.CAP_BC 0.003372687 0.010959544 0.3077 0.75828 ## lag.CAP_OCC 0.001941497 0.053815702 0.0361 0.97122 ## lag.CAP_CS 0.265435956 0.784721558 0.3383 0.73517 ## lag.Población -0.000120261 0.000146346 -0.8218 0.41122 ## ## Rho: 0.28321, LR test value: 0.99104, p-value: 0.31949 ## Approximate (numerical Hessian) standard error: 0.26283 ## z-value: 1.0775, p-value: 0.28124 ## Wald statistic: 1.1611, p-value: 0.28124 ## ## Log likelihood: -195.4676 for mixed model ## ML residual variance (sigma squared): 11616, (sigma: 107.78) ## Number of observations: 32 ## Number of parameters estimated: 17 ## AIC: 424.94, (AIC for lm: 423.93) s(reg7)#Manski ## ## Call:sacsarlm(formula = reg.eq1, data = Insumo, listw = Insumo.lw, type = &quot;sacmixed&quot;) ## ## Residuals: ## Min 1Q Median 3Q Max ## -179.6048 -72.7882 -2.7818 33.8501 346.2488 ## ## Type: sacmixed ## Coefficients: (numerical Hessian approximate standard errors) ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 307.899524827 289.173507863 1.0648 0.28699 ## PIB 0.004070842 0.002881048 1.4130 0.15766 ## NBI -0.195254186 1.932325107 -0.1010 0.91951 ## CAP_BOG 0.002531850 0.089756232 0.0282 0.97750 ## CAP_BC -0.001838769 0.009348395 -0.1967 0.84407 ## CAP_OCC -0.056119738 0.028292541 -1.9836 0.04731 ## CAP_CS 0.071595235 0.500476865 0.1431 0.88625 ## Población 0.000065749 0.000125447 0.5241 0.60019 ## lag.PIB 0.000817609 0.007040486 0.1161 0.90755 ## lag.NBI -6.096432791 5.918183252 -1.0301 0.30295 ## lag.CAP_BOG -0.052377434 0.139398457 -0.3757 0.70711 ## lag.CAP_BC 0.006801659 0.016628203 0.4090 0.68251 ## lag.CAP_OCC 0.008763485 0.049556804 0.1768 0.85964 ## lag.CAP_CS 0.219189298 0.815594280 0.2687 0.78812 ## lag.Población -0.000162608 0.000233654 -0.6959 0.48647 ## ## Rho: 0.38485 ## Approximate (numerical Hessian) standard error: 0.39392 ## z-value: 0.97698, p-value: 0.32858 ## Lambda: -0.26343 ## Approximate (numerical Hessian) standard error: 0.88846 ## z-value: -0.2965, p-value: 0.76685 ## ## LR test value: 7.7816, p-value: 0.5563 ## ## Log likelihood: -195.4082 for sacmixed model ## ML residual variance (sigma squared): 11213, (sigma: 105.89) ## Number of observations: 32 ## Number of parameters estimated: 18 ## AIC: 426.82, (AIC for lm: 416.6) s(reg8)#SARAR lag Y and lag e (SAC) ## ## Call:sacsarlm(formula = reg.eq1, data = Insumo, listw = Insumo.lw, type = &quot;sac&quot;) ## ## Residuals: ## Min 1Q Median 3Q Max ## -203.1991 -58.2427 -4.1109 46.5336 421.1733 ## ## Type: sac ## Coefficients: (numerical Hessian approximate standard errors) ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 73.149386014 83.317191361 0.8780 0.37996 ## PIB 0.003487952 0.002651478 1.3155 0.18835 ## NBI -0.337466937 1.448625357 -0.2330 0.81580 ## CAP_BOG -0.038888663 0.051162705 -0.7601 0.44720 ## CAP_BC 0.002799262 0.006077082 0.4606 0.64507 ## CAP_OCC -0.043084476 0.021594358 -1.9952 0.04602 ## CAP_CS 0.320438586 0.293526107 1.0917 0.27497 ## Población 0.000028476 0.000067569 0.4214 0.67343 ## ## Rho: 0.1104 ## Approximate (numerical Hessian) standard error: 0.19009 ## z-value: 0.58081, p-value: 0.56137 ## Lambda: 0.41973 ## Approximate (numerical Hessian) standard error: 0.27257 ## z-value: 1.5399, p-value: 0.12359 ## ## LR test value: 4.1193, p-value: 0.1275 ## ## Log likelihood: -197.2394 for sac model ## ML residual variance (sigma squared): 12624, (sigma: 112.36) ## Number of observations: 32 ## Number of parameters estimated: 11 ## AIC: 416.48, (AIC for lm: 416.6) 3.8 Calculo de varibles significativas #Calculo de variables signid¿ficativas reg.eq2=CAP_BAC ~ PIB + CAP_BOG+CAP_BC + CAP_OCC + CAP_CS+ Población reg4=errorsarlm(reg.eq2,data=Insumo, Insumo.lw) s(reg4)#Lag Error (SEM) ## ## Call:errorsarlm(formula = reg.eq2, data = Insumo, listw = Insumo.lw) ## ## Residuals: ## Min 1Q Median 3Q Max ## -211.1287 -54.9469 -1.1316 40.5690 428.8317 ## ## Type: error ## Coefficients: (asymptotic standard errors) ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 82.780382772 57.200030716 1.4472 0.14784 ## PIB 0.003786089 0.002550194 1.4846 0.13764 ## CAP_BOG -0.033655764 0.049317358 -0.6824 0.49497 ## CAP_BC 0.001072562 0.005563108 0.1928 0.84712 ## CAP_OCC -0.049110630 0.019547548 -2.5124 0.01199 ## CAP_CS 0.290079781 0.285013019 1.0178 0.30878 ## Población 0.000039933 0.000066827 0.5976 0.55013 ## ## Lambda: 0.51895, LR test value: 4.4697, p-value: 0.0345 ## Approximate (numerical Hessian) standard error: 0.20419 ## z-value: 2.5415, p-value: 0.011039 ## Wald statistic: 6.4591, p-value: 0.011039 ## ## Log likelihood: -197.4239 for error model ## ML residual variance (sigma squared): 12470, (sigma: 111.67) ## Number of observations: 32 ## Number of parameters estimated: 9 ## AIC: 412.85, (AIC for lm: 415.32) reg.eq3=CAP_BAC ~ PIB + CAP_BOG + CAP_OCC + CAP_CS+ Población reg4=errorsarlm(reg.eq3,data=Insumo, Insumo.lw) s(reg4)#Lag Error (SEM) ## ## Call:errorsarlm(formula = reg.eq3, data = Insumo, listw = Insumo.lw) ## ## Residuals: ## Min 1Q Median 3Q Max ## -214.6537 -56.5893 -1.9568 41.1618 430.2455 ## ## Type: error ## Coefficients: (asymptotic standard errors) ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 76.659388419 48.733987996 1.5730 0.1157149 ## PIB 0.003936351 0.002412095 1.6319 0.1026960 ## CAP_BOG -0.026724271 0.035542537 -0.7519 0.4521140 ## CAP_OCC -0.051550780 0.014822573 -3.4779 0.0005054 ## CAP_CS 0.249952769 0.204318663 1.2233 0.2211984 ## Población 0.000047471 0.000055107 0.8614 0.3890008 ## ## Lambda: 0.52489, LR test value: 4.7822, p-value: 0.028756 ## Approximate (numerical Hessian) standard error: 0.19904 ## z-value: 2.6371, p-value: 0.008363 ## Wald statistic: 6.9541, p-value: 0.008363 ## ## Log likelihood: -197.4421 for error model ## ML residual variance (sigma squared): 12461, (sigma: 111.63) ## Number of observations: 32 ## Number of parameters estimated: 8 ## AIC: 410.88, (AIC for lm: 413.67) reg.eq4=CAP_BAC ~ PIB + CAP_OCC + CAP_CS+ Población reg4=errorsarlm(reg.eq4,data=Insumo, Insumo.lw) s(reg4)#Lag Error (SEM) ## ## Call:errorsarlm(formula = reg.eq4, data = Insumo, listw = Insumo.lw) ## ## Residuals: ## Min 1Q Median 3Q Max ## -200.4867 -63.5891 -8.8979 41.1675 444.7078 ## ## Type: error ## Coefficients: (asymptotic standard errors) ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 78.047294223 51.760317159 1.5079 0.1315904 ## PIB 0.003727043 0.002409110 1.5471 0.1218483 ## CAP_OCC -0.050131489 0.014726792 -3.4041 0.0006638 ## CAP_CS 0.099564078 0.037675929 2.6426 0.0082261 ## Población 0.000057480 0.000053995 1.0646 0.2870778 ## ## Lambda: 0.56286, LR test value: 6.894, p-value: 0.0086485 ## Approximate (numerical Hessian) standard error: 0.17904 ## z-value: 3.1437, p-value: 0.001668 ## Wald statistic: 9.8832, p-value: 0.001668 ## ## Log likelihood: -197.7004 for error model ## ML residual variance (sigma squared): 12505, (sigma: 111.82) ## Number of observations: 32 ## Number of parameters estimated: 7 ## AIC: 409.4, (AIC for lm: 414.29) reg.eq5=CAP_BAC ~ PIB + CAP_OCC + CAP_CS reg4=errorsarlm(reg.eq5,data=Insumo, Insumo.lw) s(reg4)#Lag Error (SEM) ## ## Call:errorsarlm(formula = reg.eq5, data = Insumo, listw = Insumo.lw) ## ## Residuals: ## Min 1Q Median 3Q Max ## -189.815 -68.002 -13.434 35.002 443.595 ## ## Type: error ## Coefficients: (asymptotic standard errors) ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 100.98165936 46.44259678 2.1743 0.029680 ## PIB 0.00611113 0.00092889 6.5789 0.00000000004738 ## CAP_OCC -0.04669321 0.01466331 -3.1844 0.001451 ## CAP_CS 0.07261035 0.02868558 2.5312 0.011366 ## ## Lambda: 0.54225, LR test value: 6.0083, p-value: 0.014239 ## Asymptotic standard error: 0.17423 ## z-value: 3.1123, p-value: 0.0018565 ## Wald statistic: 9.6862, p-value: 0.0018565 ## ## Log likelihood: -198.2513 for error model ## ML residual variance (sigma squared): 13034, (sigma: 114.17) ## Number of observations: 32 ## Number of parameters estimated: 6 ## AIC: 408.5, (AIC for lm: 412.51) 3.9 Mapa Estimado ###Mapa estimado fit = reg4$fitted.values #dev.new() #windows() shade.fit = shading(c(100,130,200,400), cols=(brewer.pal(5,&quot;Reds&quot;))) choropleth(Insumo, fit, shading=shade.fit) choro.legend(1555874,535165.5, shade.fit, fmt=&quot;%1.2f&quot;, title = &quot;Estimaciones&quot;, cex=0.7, under = &quot;Menos de&quot;, between = &quot;a&quot;, over = &quot;Mas de&quot;) title(&quot;Valores ajustados mediante el modelo SEM para las captaciones del banco agrario en Colombia, cuarto trimestre 2020&quot;, cex.main=1) map.scale(755874,335165.5, 250000, &quot;km&quot;, 2, 50, sfcol=&#39;brown&#39;) ###R^2 Nagelkerke # summary.sarlm(reg4,Nagelkerke = TRUE) TO-DO ###Test de moran residuales modelo SEM moran.test(reg4$residuals, Insumo.lw) ## ## Moran I test under randomisation ## ## data: reg4$residuals ## weights: Insumo.lw ## ## Moran I statistic standard deviate = 0.83723, p-value = 0.2012 ## alternative hypothesis: greater ## sample estimates: ## Moran I statistic Expectation Variance ## 0.05266907 -0.03225806 0.01028984 #Municipal ColombiaM = readOGR(dsn = &quot;Trabajo Grado/Geodatabase Colombia&quot;, layer = &quot;municipios&quot;) ## OGR data source with driver: ESRI Shapefile ## Source: &quot;/home/jncc/Documents/Notebooks/Monitorias/Bookdown/Cuadernos/Trabajo Grado/Geodatabase Colombia&quot;, layer: &quot;municipios&quot; ## with 1107 features ## It has 6 fields ## Integer64 fields read as strings: COD_MUN COD_DEPTO "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
