---
title: "Random Fields"
author: "Martha Bohorquez"
date: "2022-12-22"
output: html_document
---

# Random Fields

## Script Fields geoest simul

```{r}
library(fields)
library(geoR)
library(Matrix)
```

```{r}
x11()
plot(0:1.5, 0:1.5, type="n")
data(lennon)
add.image(0.5,0.5,lennon, col=grey((0:256)/256),image.width=1,image.heigth=1)
#add.image(0.5,0.5,lennon, col=tim.colors(256),image.width=1,image.heigth=1)
# reference lines
xline(0.5, col=3)
yline(0.5,col=4)

x11()
datos=cbind(x=rnorm(50),y=rnorm(50),z=rnorm(50))
datosIm<- as.image(datos[,3], x=datos[,1:2])
image.plot(datosIm)
```

```{r}

#datos Chicago ozone test data
#ChicagoO3
#x tiene ID, este, norte
#y son los datos de ozono
```

```{r}
#Thin plate spline regression
fit_TPS<- Tps(ChicagoO3$x, ChicagoO3$y)
x11()
par(mfrow=c(1,2))
surface.Krig(fit_TPS,type="p",extrap=F)
surface.Krig(fit_TPS,type="C",extrap=F)
surface.Krig(fit_TPS,type="I",extrap=F)
```

```{r}
# fitting a surface to ozone measurements.
fit_Krig<- Krig(ChicagoO3$x, ChicagoO3$y, Covariance="Matern", aRange=100,smoothness=2,sigma=var(ChicagoO3$y))
data(ozone2)
surface.Krig(fit_Krig,type="C",extrap=F)
x<- ozone2$lon.lat
y<- ozone2$y[16,]
# Omit the NAs
good<- !is.na( y)
x<- x[good,]
y<- y[good]
```

```{r}
#simulation with circulant embedding. Simula un GRF en una grilla regular con silla=1. El algoritmo circulant embedding usa FFT.
```

```{r}
#Usar con alcances no tan grandes o agrandando el spatial domain
grid<- list(x= seq(0,5,len=100), y= seq(0,5,len=150))
obj<- circulantEmbeddingSetup(grid, Covariance="Exponential", aRange=.5)
set.seed(223)
look<- circulantEmbedding(obj)
# Now simulate another ...
look2<- circulantEmbedding(obj)
# Suppose one requires an exponential, range = 2
# but marginal variance = 10 ( sigma in fields notation)
look3<- sqrt( 10)*circulantEmbedding(obj)
#Now with antique function
grid<- list( x= seq(0,5,length=100) , y= seq(0,5,len=150) )
obj<-Exp.image.cov(grid=grid, aRange=.75, setup=TRUE)
set.seed( 223)
look4<- sim.rf( obj)
# take a look at first 4
X11()
par(mfrow=c(2,2))
image.plot(grid[[1]], grid[[2]],look)
title("simulated gaussian fields")
image.plot( grid[[1]], grid[[2]],look2)
title("Second realization ...")
image.plot( grid[[1]], grid[[2]],look3)
title("Third realization ...")
image.plot(grid[[1]], grid[[2]],look4)
title("Fourth realization with sim.rf ...")
```

```{r}
#calculando covarianzas entre conjuntos de puntos, esto sirve para las distancias
#entre observados y lugares a predecir por ej.
```

```{r}
out2<- Exp.cov( ChicagoO3$x[6:20,],ChicagoO3$x[1:2,], aRange=100)
```

```{r}
# an interesting 3D field
##el det de la matriz cov da casi cero
grid<- list(1:40, 1:40, 1:16)
obj<- circulantEmbeddingSetup(grid,cov.args=list(Covariance="Matern", aRange=2, smoothness=1.0))
```

```{r}
# NOTE: choice of aRange is close to giving a negative weight array
set.seed(102)
look<- circulantEmbedding(obj)
# look at slices in the 3rd dimension
set.panel(4,4)
zr<- range(look)
par( mar=c(1,1,0,0))
for( k in 1:16){
  image(grid[[1]], grid[[2]], look[,,k], zlim= zr, col=tim.colors(256),
         axes=FALSE, xlab="", ylab="")
}
```

```{r}
data(ozone2)
quilt.plot(ozone2$lon.lat, ozone2$y[16,],main="day 16")
bubblePlot(ozone2$lon.lat, ozone2$y[16,],main="day 16")
US( add=TRUE, col="magenta", lwd=2)

data(CO2)
```

```{r}
#
# A quick look at the observations with world map
#x11()
#quilt.plot(CO2$lon.lat, CO2$y[20,])
#bubblePlot(CO2$lon.lat, CO2$y[20,])
#world(add=TRUE)
out<-fastTps(CO2$lon.lat, CO2$y, aRange=4, lambda=2.0)
#summary of fit note about 7300 degrees of freedom
# associated with fitted surface
print( out)
#image plot on a grid
surface( out, type="I", nx=300, ny=150)
#surface( out2, type="I", nx=300, ny=150)
out2<-fastTps(CO2$lon.lat, CO2$y, lon.lat=TRUE,lambda=1.5, aRange=4*68)
print(out2)
surface(out2, type="I", nx=300, ny=150)
#vector de colores
coltab<- two.colors( 256, middle="grey50")
```

```{r}

#Wendland covariance 
##esta matriz da con determinante igual a cero, es de soporte compacto
dt<- seq( 0,1.5, 200)
y<- Wendland(dt, k=2, dimension=2)
plot( dt, y, type="l")
y.test<- Wendland2.2( dt)
points( dt, y.test)
```

```{r}
# these data are actually subsampled from a grid.
# create the image object that holds the data
#
```

```{r}

temp<- matrix(NA, ncol=ncol(CO2.true$z), nrow=nrow(CO2.true$z))
temp[ CO2.true$mask] <- CO2$y
# look at gridded object.
image.plot(CO2.true$x,CO2.true$y, temp)
# to predict _exactly_ on this grid for the second fit;
# (this take a while)
data(CO2)
#surface( out2, type="I", nx=300, ny=150)
#Fits a thin plate spline surface and it uses a compactly supported Wendland covariance 
#is a special case of a Gaussian process estimate as the range parameter in the Matern family 
#increases to infinity. (Kriging).  GAM
#m-1 es el grado del polinomio para la tendencia, p la potencia polinomia para Wendland
out2<-fastTps(CO2$lon.lat, CO2$y, lon.lat=TRUE,lambda=1.5, aRange=4*68)
print(out2)
look<- predictSurface(out2, grid.list=list( x=CO2.true$x, y=CO2.true$y))
x11()
set.panel(2,1)
surface(out2, type="I", nx=300, ny=150)
image.plot(look)
```

```{r}

#BD es un data.frame, la variable respuesta es BD$lnya
fit<- Tps(BD[,1:4], BD$lnya)  # fit surface to data 
# evaluate fitted surface for  first two variables holding other two fixed at median values
out.p<- predictSurface(fit)
surface(out.p, type="C") 
# plot surface for second and fourth variables on specific grid. 
glist<- list(KCL=29.77, MgCl2= seq(3,7,,25), KPO4=32.13, dNTP=seq(250,1500,,25))
out.p<- predictSurface(fit, glist)
surface(out.p, type="C")
#plot surface of standard deviation for second and fourth variables on specific grid. 
out.p<- predictSurfaceSE(fit, glist)
surface(out.p, type="C")
```

```{r}

##la mas eficiente para m=2,k=2
look1<-predictSurface.fastTps(out2, grid.list=list( x=CO2.true$x, y=CO2.true$y))
image.plot(look1)
# second derivative
x11()
curve(Wendland(x, k=1, dimension=2, derivative=2),0,1.5,ylim=c(-25,12))
curve(Wendland(x, k=2, dimension=2, derivative=2),add=T,col=2)
curve(Wendland(x, k=3, dimension=2, derivative=2),add=T,col=3)
curve(Wendland(x, k=3, dimension=4, derivative=2),add=T,col=4)
#calculando la distancia a un knot
#El gráfico no funciona con matrices pequeñas, funciona a partir de matrices de dimensión 60x60
gl<- list( x= seq( -1,1,,250), y = seq( -1,1,,250) )
#matriz de distancias al knot
bigD<- rdist( make.surface.grid( gl), matrix( c(.25,.25), nrow=1))
#covMatrix
RBF<- matrix(Wendland( bigD, k=2, dimension=2), 250,250)
# perspective with some useful settings for shading.
persp( gl$x, gl$y, RBF, theta =30, phi=20, shade=.3, border=NA, col="grey90")
```

```{r}

#ejemplo 2, dando el aRange
#ahora se guarda de forma compacta en un vector, solo los elementos del triáng inf
gl<- list( x= seq(-1,1,,65), y = seq(-1,1,,65))
#si no se le da ningún parámetro queda igual que distancia
dista=rdist(make.surface.grid(gl))
##para guardar solo el triángulo inferior
dista=rdist(make.surface.grid(gl),compact=TRUE)
diagVal = Exponential(0, range=0.3)#el range aquí no cumple ninguna función
compactCovMat = Exponential(dista, range=0.3)
upperCovMat = compactToMat(compactCovMat, diagVal)
lowerCovMat = compactToMat(compactCovMat, diagVal, lower.tri=TRUE, upper.tri=FALSE)
fullCovMat = compactToMat(compactCovMat, diagVal, lower.tri=TRUE, upper.tri=TRUE)
#con la Wendland , aRange hasta donde tiene en cuenta las distancias
diagVal = Wendland(0, aRange=0.3,k=2, dimension=2)#el range aquí no cumple ninguna función
compactCovMat = Wendland(dista,aRange=0.3,k=2,dimension=2)
upperCovMat = compactToMat(compactCovMat, diagVal)
lowerCovMat = compactToMat(compactCovMat, diagVal, lower.tri=TRUE, upper.tri=FALSE)
fullCovMatWendland=compactToMat(compactCovMat, diagVal, lower.tri=TRUE, upper.tri=TRUE)
#solo se puede graficar la superficie de covarianza con la distancia a un knot.
#evaluate Exponential covariance with range=1. Note that
#Covariance function is only evaluated over upper triangle
#so time is saved.
```

```{r}

#Ejemplo suavizar para el mapa espacial
data(COmonthlyMet)
#Spatial plot of 1997 Spring average daily maximum temps
quilt.plot( CO.loc,CO.tmax.MAM[103,] )
US( add=TRUE)
title( "Recorded MAM max temperatures (1997)")
# min and max temperatures against elevation
matplot(CO.elev, cbind(CO.tmax.MAM[103,], CO.tmin.MAM[103,]),pch="o", type="p",
col=c("red", "blue"), xlab="Elevation (m)", ylab="Temperature (C)")
title("Recorded MAM max (red) and min (blue) temperatures 1997")
#Fitting a spatial model:
obj<- Tps(CO.loc,CO.tmax.MAM.climate,Z= CO.elev)
out<- spatialProcess(CO.loc,CO.tmax.MAM.climate,smoothness=1.0, Z= CO.elev)
surface(out)
```

```{r}

#Opciones para la construcción de matrices de covarianza
ChicagoO3$x #Id y coordenadas planas
#matrices de covarianza
Cov_exp<- Exp.cov(ChicagoO3$x, aRange=100)
Cov_exp_dif_conjDpuntos<-Exp.cov(ChicagoO3$x[6:20,],ChicagoO3$x[1:2,], aRange=100)
Cov_matern<-stationary.cov(ChicagoO3$x, aRange=150, Covariance = "Matern",smoothness=1.5)
det(Cov_matern)
```

```{r}

############################################################
###profundizar teoría
############################################################
Cov_RadCov<-Rad.cov(ChicagoO3$x, m=2, with.log = TRUE, with.constant = TRUE)
Cov_Taper<-stationary.taper.cov(ChicagoO3$x, Covariance="Exponential",Taper="Wendland",Taper.args=list(k=2,aRange=100,dimension=2)) 
##ver también https://search.r-#project.org/CRAN/refmans/CompRandFld/html/Covmatrix.html
##calculando directamente el producto para la stationary covar taper
Exponential(rdist(ChicagoO3$x)/100)*Wendland(rdist(ChicagoO3$x)/100,dimension=2,k=2)
```

```{r}
##kriging, por defecto exponencial, m es el grado del polinomio de tendencia encontrado
#ajusta la superficie
fit <- Krig(ChicagoO3$x, ChicagoO3$y,m=2,aRange=20)  #tendencia cúbica
#fit1 <- Krig(ChicagoO3$x, ChicagoO3$y,m=1,aRange=20)  #tendencia cuadrática
#fit <- Krig(ChicagoO3$x, ChicagoO3$y,Covariance="Matern", aRange=10, smoothness=1.0)
summary(fit) # summary of fit
predictSE(fit)
set.panel(2,2)
plot(fit) # four diagnostic plots of fit
set.panel()
surface(fit, type="C") # look at the surface
#para predecir en los lugares observados, pero veo que hace lo mismo que la fun anterior
#predict(fit)
#out<- predictSurface( fit)
#surface( out, type="C") # option "C" our favorite
############################################################
#######
############################################################
# predict at arbitrary points (10,-10) and (20, 15)
xnew<- rbind(c( 10, -10), c( 20, 15))
predict(fit, xnew)
# standard errors of prediction based on covariance model.
predictSE(fit, xnew)
##out es idéntico a out1
out<- Krig(ChicagoO3$x, ChicagoO3$y,cov.function="Rad.cov",m=2,p=2,scale.type="range")
out1<-Tps(ChicagoO3$x, ChicagoO3$y)
```

```{r}

# predict en una grilla de puntos
xnew<- cbind(seq(10,20,len=25), seq(-10,15,len=25))
predicc=predict(fit, xnew)
# standard errors of prediction based on covariance model.
SEpredicc=predictSE(fit, xnew)
set.panel(2,1)
plot(predicc)
plot(SEpredicc)
surface(predicc, type="C")
surface(SEpredicc, type="C")
```

```{r}

############################################################
####
############################################################

# an example using a "Z" covariate and the Matern family, ver mKrigMLEGrid to choose covariance parameters by MLE, esta función 
#selecciona automáticamente los rangos y sillas de entre varios modelos
##semiparamétrico, hace predicción en una grilla dispersa y luego hace el promedio de vecinos cercanos, eficiente
#una covariable en este ejemplo
data(COmonthlyMet)
yCO<- CO.tmin.MAM.climate
good<- !is.na( yCO)
yCO<-yCO[good]
xCO<- CO.loc[good,]
Z<- CO.elev[good]
out<- mKrig(xCO,yCO, Z=Z, cov.function="stationary.cov", Covariance="Matern",aRange=4.0, smoothness=1.0, lambda=.1)
```

```{r}

##no corre el argumento grid.list
###como es  se le puede dar unos puntos de predicción
xnew<- cbind(seq(-109.4,-101,len=250), seq(37,41,len=250))
out<- mKrig(xCO,yCO, cov.function="stationary.cov", Covariance="Matern",aRange=4.0, smoothness=1.0, lambda=.1)
sim.out=predict(out,xnew=xnew)
set.panel(2,1)
# quilt.plot with elevations
quilt.plot(xCO, predict(out))
# Smooth surface without elevation linear term included
surface(out)
# a "Kriging" model. The covariance defaults to a Matern with smoothness 1.0.
# the nugget, sill and range parameters are found by maximum likelihood
# summary, plot, and surface also work for fit2 !
fit2<- spatialProcess(xCO,yCO)
surface(fit2)
```

```{r}

############################################################
####Conditional simulation
##### función de simulación condicional restringida a fun de cov estacionarias
############################################################
```

```{r}

#simulationGridList en este parámetro se le dan las ubicaciones de interés, si no se le da
#la función las crea dentro de los rangos 
data(ozone2)
set.seed(399)
```

```{r}

# fit to day 16 from Midwest ozone data set.
##construir variando rango y parámetro de suavidad los datos originales por ejemplo con simulación no condicional
#o si se tienen datos construir esta superficie primero
outMat<- Krig(ozone2$lon.lat, ozone2$y[16,], Covariance="Matern",aRange=1.0,smoothness=1.0, na.rm=TRUE)
outWend<- Krig(ozone2$lon.lat, ozone2$y[16,], Covariance="Wendland",k=2, dimension=2, aRange=1.0, na.rm=TRUE)
outMat2<- Krig(ozone2$lon.lat, ozone2$y[16,], Covariance="Matern",aRange=0.8,smoothness=1.5, na.rm=TRUE)
```

```{r}

# NOTE aRange =1.0 is not the best choice but
# allows the sim.rf circulant embedding algorithm to
# work without increasing the domain.
#six missing data locations
xp<- ozone2$lon.lat[is.na(ozone2$y[16,]),]
```

```{r}

# M draws from process at xp given the data
# this is an exact calculation, una grilla de interés dada
##se podrían hacer varias simulaciones y tomarles media o mediana por punto
xp=matrix(c(seq(-82,-93,len=10),seq(37,44.4,len=10)),nrow=10,ncol=2,byrow=F)
sim.outMat<-sim.Krig(outMat,xp,M=1)
sim.outWen<-sim.Krig(outWend,xp,M=1)
sim.outMat2<-sim.Krig(outMat2,xp,M=1)
sim.outMat_table<-cbind(xp,t(sim.outMat))
colnames(sim.outMat_table)=c("x","y","z")
sim.outWen_table<-cbind(xp,t(sim.outWen))
colnames(sim.outWen_table)=c("x","y","z")
sim.outMat2_table<-cbind(xp,t(sim.outMat2))
colnames(sim.outMat2_table)=c("x","y","z")
set.panel(1,3)
boxplot(sim.outMat_table[,3])
boxplot(sim.outWen_table[,3])
boxplot(sim.outMat2_table[,3])
cvMat=sd(sim.outMat_table[,3])/mean(sim.outMat[,3])
cvWen=sd(sim.outWen_table[,3])/mean(sim.outWen[,3])
cvMat2=sd(sim.outMat2_table[,3])/mean(sim.outMat2[,3])
```

```{r}

##por defecto usa 40 puntos y arroja la grilla en forma de matriz, cuadrícula, tridimensional
##si se simulan M>1  la simulaciones se van poniendo en capas
sim.out3<-sim.Krig.approx(out,nx=5,ny=4,gridRefinement=3,M=1)
sim.out3<-sim.Krig.approx(out,2,M=1)
```

```{r}

data( ozone2)
set.seed( 399)
# fit to day 16 from Midwest ozone data set.
out<- Krig( ozone2$lon.lat, ozone2$y[16,], Covariance="Matern",
aRange=1.0,smoothness=1.0, na.rm=TRUE)
# NOTE aRange =1.0 is not the best choice but
# allows the sim.rf circulant embedding algorithm to
# work without increasing the domain.
#six missing data locations
xp<- ozone2$lon.lat[ is.na(ozone2$y[16,]),]
# 5 draws from process at xp given the data
# this is an exact calculation
sim.Krig( out,xp, M=5)-> sim.out
```

```{r}

#Compare: stats(sim.out)[3,] to Exact: predictSE( out, xp)
#simulations on a grid NOTE this is approximate due to the bilinear interpolation for simulating the unconditional random field. also more grids points ( nx and ny) should be used
sim.Krig.approx(out,M=5, nx=20,ny=20)-> sim.out
# take a look at the ensemble members.
predictSurface( out, grid= list( x=sim.out$x, y=sim.out$y))-> look
zr<- c( 40, 200)
set.panel( 3,2)
image.plot( look, zlim=zr)
title("mean surface")
for (k in 1:5){image( sim.out$x, sim.out$y, sim.out$z[,,k], col=tim.colors(), zlim =zr)}
```

```{r}

########################################################################################################################
##conditional simulation based on semiparametric micro kriging, combinación kriging y el vecino mas cercano
########################################################################################################################
# conditional simulation at missing data
xMissing<- ozone2$lon.lat[!good,]
O3.sim2<- sim.mKrig.approx( O3.fit, xMissing, nx=80, ny=80,gridRefinement=3, M=4 )
#################% Cinco
###simulaciones del mismo proceso 
data(ozone2)
y<- ozone2$y[16,]
good<- !is.na( y)
y<-y[good]
x<- ozone2$lon.lat[good,]
O3.fit<- mKrig( x,y, Covariance="Matern", aRange=.5,smoothness=1.0, lambda= .01 )
set.seed(122)
O3.sim<- sim.mKrig.approx( O3.fit, nx=100, ny=100, gridRefinement=3, M=5 )
set.panel(3,2)
surface( O3.fit)
for ( k in 1:5){
image.plot( as.surface( O3.sim$predictionPoints, O3.sim$Ensemble[,k]) )
}
# conditional simulation at missing data
xMissing<- ozone2$lon.lat[!good,]
O3.sim2<- sim.mKrig.approx( O3.fit, xMissing, nx=80, ny=80,gridRefinement=3, M=4 )
```

```{r}

########################################################################################################################
###muy eficiente computacionalmente, simular condicionando sobre la superficie suavizada 
########################################################################################################################
data(ozone2)
y<- ozone2$y[16,]
good<- !is.na( y)
y<-y[good]
x<- ozone2$lon.lat[good,]
O3Obj<- fastTps( x,y, aRange=1.5 )
# creating a quick grid list based on ranges of locations
grid.list<- fields.x.to.grid( O3Obj$x, nx=10, ny=10)
# controlling the grids
xR<- range( x[,1], na.rm=TRUE)
yR<- range( x[,2], na.rm=TRUE)
simulationGridList<- list( x= seq(xR[1],xR[2],,20),
y= seq( yR[1],yR[2], ,20))
# very fine localized prediction grid
O3GridList<- list( x= seq( -90.5,-88.5,,40), y= seq( 38,40,,40))
O3Sim<- sim.mKrig.approx(O3Obj, M=1, predictionPointsList=O3GridList,simulationGridList = simulationGridList)
```



## Rutinas Paper 3 basis orthon

```{r}
########################################################################
#paper 3
#########################################################################

rm(list=ls())

library(sp)
library(gstat)
```

```{r}
#################simulaci?n funciones peri?dicas con bases de Fourier#################
#The Fourier basis is an orthonormal basis of L2, over any interval of length 2pi#

#eigenfunctions1 Fourier basis [0,2pi]  o  [a,a+2pi]
en=function(x,n){((sqrt(2*pi))^(-1))*exp(1i*n*x)}
#Ejemplo 0.005*en(x,1)+5*en(x,2)
curve(0.005*en(x,1)+5*en(x,2),0,2*pi)
```

```{r}
#eigenfunctions2 series Fourier [-L,L]
seno_fourier=function(x,n,L){sqrt(2/L)*sin(n*pi*x/L)}
coseno_Fourier=function(x,n,L){sqrt(2/L)*cos(n*pi*x/L)}
#series_Fourier=function(x,n,L){1/sqrt(L)+seno_fourier(x,1,L)+...+seno_fourier(x,n,L)+coseno_fourier(x,1,L)+...+coseno_fourier(x,n,L)}
```

```{r}
##En L2[-1/2,1/2] n=1
integrand <- function(x) {(sqrt(2)*sin(2*1*x*pi))^2}
integrate(integrand, lower = 0, upper =1)
##En L2[-1/2,1/2] n=2
integrand <- function(x) {(sqrt(2/1)*sin(2*2*x*pi))^2}
integrate(integrand, lower = 0, upper =1)
##En L2[-1/2,1/2] n=3
integrand <- function(x) {(sqrt(2/1)*sin(2*3*x*pi))^2}
integrate(integrand, lower = 0, upper =1)
```

```{r}
###coseno verificando que todos tienen norma 1
coseno_Fourier=function(x,n,L){sqrt(2/L)*cos(n*pi*x/L)}
##En L2[-1/2,1/2] n=1
integrand <- function(x) {(sqrt(2)*cos(2*1*x*pi))^2}
integrate(integrand, lower = 0, upper =1)
##En L2[-1/2,1/2] n=2
integrand <- function(x) {(sqrt(2/1)*cos(2*2*x*pi))^2}
integrate(integrand, lower = 0, upper =1)
##En L2[-1/2,1/2] n=3
integrand <- function(x) {(sqrt(2/1)*cos(2*3*x*pi))^2}
integrate(integrand, lower = 0, upper =1)
##En L2[-1/2,1/2] n=4
integrand <- function(x) {(sqrt(2/1)*cos(2*4*x*pi))^2}
integrate(integrand, lower = 0, upper =1)
```

```{r}
###seno verificando que todos tienen norma 1
seno_fourier=function(x,n,L){sin(n*pi*x/L)}
##En L2[0,1] n=1
integrand <- function(x) {(sqrt(2)*sin(2*1*x*pi))^2}
integrate(integrand, lower = 0, upper =1)
##En L2[-1/2,1/2] n=2
integrand <- function(x) {(sqrt(2/1)*sin(2*2*x*pi))^2}
integrate(integrand, lower = 0, upper =1)
##En L2[-1/2,1/2] n=3
integrand <- function(x) {(sqrt(2/1)*sin(2*3*x*pi))^2}
integrate(integrand, lower = 0, upper =1)
```

```{r}
###coseno verificando que todos tienen norma 1
coseno_Fourier=function(x,n,L){sqrt(2/L)*cos(n*pi*x/L)}
##En L2[-1/2,1/2] n=1
integrand <- function(x) {(sqrt(2)*cos(2*1*x*pi))^2}
integrate(integrand, lower = 0, upper =1)
##En L2[-1/2,1/2] n=2
integrand <- function(x) {(sqrt(2/1)*cos(2*2*x*pi))^2}
integrate(integrand, lower = 0, upper =1)
##En L2[-1/2,1/2] n=3
integrand <- function(x) {(sqrt(2/1)*cos(2*3*x*pi))^2}
integrate(integrand, lower = 0, upper =1)
##En L2[-1/2,1/2] n=4
integrand <- function(x) {(sqrt(2/1)*cos(2*4*x*pi))^2}
integrate(integrand, lower = 0, upper =1)
```

```{r}
### verificando que todos son ortogonales
integrand <- function(x) {(sqrt(2)*cos(2*1*x*pi))*(sqrt(2/1)*sin(2*5*x*pi))}
integrate(integrand, lower = 0, upper =1)
integrand <- function(x) {(sqrt(2)*cos(2*2*x*pi))*(sqrt(2/1)*cos(2*3*x*pi))}
integrate(integrand, lower = 0, upper =1)
integrand <- function(x) {(sqrt(2)*sin(2*1*x*pi))*(sqrt(2/1)*sin(2*5*x*pi))}
integrate(integrand, lower = 0, upper =1)
```

```{r}
#Ejemplo 0.0005*1+0.005*seno_fourier(x,1,5)+5*coseno_Fourier(x,1,5) 
```

```{r}
#eigenfunctions3 Legendre, ver conway pag18 ejercicio 6, L^2[-1,1]
v1=function(x){sqrt(1/2)}
v2=function(x){x*sqrt(3/2)}
v3=function(x){(3/2)*(sqrt(5/2))*(-(1/3)+x^2)}
v4=function(x){(5/2)*(sqrt(7/2))*(-(3*x/5)+x^3)}
#Ejemplo 0.005*5sqrt(1/2)+0.05*v2(x)+0.5*v3(x)+7*v4(x)
```

```{r}
integrand=function(x){((3/2)*(sqrt(5/2))*(-(1/3)+x^2))*((5/2)*(sqrt(7/2))*(-(3*x/5)+x^3))}


#eigenfunctions4 Hermite, ver conway pag18 ejercicio 7

#eigenfunctions5 Laguerre, ver conway pag18 ejercicio 8

####################generaci?n del proceso espacial multivariado de scores#######################

##Caso 1 Dos variables 
##Supongamos un solo vector propio completa mas del % requerido ejem. 90% para ambas funciones

#chi1=f11*v1+...+f1k*vk+...    
#chi2=f21*v1+...+f1k*vk+...    
#...
#chin=fn1*v1+...+fnk*vk+...    

#F1=c(f11,...,fn1)
#G11=c(g11,...,gn1)
#Cov_F1=exponencial, silla valor propio 1 (9), rango 1, no pepita
#Cov_G1=exponencial, silla valor propio 1 (4), rango 2, no pepita
#cross_covFG=exponencial, silla valor propio 1 (5), rango 2, no pepita
```

```{r}
#to ensure the variogram model of the vector with two processes is valid is enough to verify that abs(sigma12)<=sqrt(sigma11*sigma22)
#Total variability 5.4
xi1=5*en(x,2)
x12=0.05*en(x,1)
#Total variability 8.6
zeta1=8*en(x,4)
zeta2=0.4*en(x,7)
```

```{r}
xy <- expand.grid(1:3, 1:4)
names(xy) <- c("x","y")
g<- gstat(id="F1",formula = F1~1, dummy=T,locations = ~x+y,beta=5)
g<- gstat(g,id="G1",formula = G1~1, dummy=T,locations = ~x+y,beta=10)
g<-gstat(g,id="F1",model = vgm(9,"Mat",30, kappa=1,add.to=vgm(1,"Sph",10)), nmax = 20)
g<-gstat(g,id="G1",model = vgm(1,"Mat",30, kappa=1,add.to=vgm(4,"Sph",10)), nmax = 20)
g<- gstat(g,id=c("F1","G1"),model = vgm(2,"Mat",30,kappa=1,add.to=vgm(1.5,"Sph",10)), nmax = 20)
yy <- predict(g, newdata = xy, nsim = 2)
```

```{r}
yydatos1=data.frame(x=yy[,1],y=yy[,2],Fsim1=yy[,3],Gsim1=yy[,5])
coordinates(yy)=~x+y
gsim1 <- gstat(id = "Fsim1", formula = Fsim1~1,  data=yy)
gsim1 <- gstat(gsim1, id = "Gsim1", formula = Gsim1~1,  data = yy)
plot(variogram(gsim1))
```

```{r}
yydatos2=data.frame(x=yy[,1],y=yy[,2],Fsim2=yy[,4],Gsim2=yy[,6])
coordinates(yydatos2)=~x+y
gsim2 <- gstat(id = "Fsim2", formula = Fsim2~1, data=yy)
gsim2 <- gstat(gsim2, id = "Gsim2", formula = Gsim2~1,  data = yy)
x11()
plot(variogram(gsim2))
```

```{r}
#Para graficar
plot(variogramLine(vgm(9,"Mat",30, kappa=1,add.to=vgm(0,"Sph",10)), maxdist=10),type="l")
```

```{r}
chi_i=function(xi,f){f*xi}


#simulaci?n condicional 
#datos=
#x=c(1,2,3,4)
#y=c(2,3,4)
#grilla=expand.grid(x,y)
#...

integrand <- function(x) {(1/(pi))*(sin(x*pi))^2}
integrate(integrand, lower = 0, upper = 2*pi)

integrand <- function(x){(sqrt(2/1)*sin(2*pi*x/1))^2}
```

## Sim spat proc gaus freq v2

```{r}
#library(funData)
library("ggplot2")
```

```{r}
simSpatFunData <- function(argvals, Ph=FALSE, ValPh, f, M, eFunType, ignoreDeg = NULL, trueVals, scores, N)
#argvals:   A numeric vector, containing the observation points (a fine grid on a real interval) of the functional data that is to be   #           simulated.
#Phase:     A vector with the phase shift of the generated curves (N).
#M          An integer, giving the number of univariate basis functions to use. 
#eFunType   A character string specifying the type of univariate orthonormal basis functions to use. For data on higher-dimensional    #            domains, eFunType can be a vector, specifying the marginal type of eigenfunctions to use in the tensor product. See
#            eFun for details.
#ignoreDeg  A vector of integers, specifying the degrees to ignore when generating the univariate orthonormal bases. Defaults to NULL.
#           For higher-dimensional data, ignoreDeg can be supplied as list with vectors for each marginal. See eFun for details.
#N          An integer, specifying the number of functions to be generated. This number correspondes to the number of sites. 

#The following arguments are deleted: 
#eValType   A character string, specifying the type of eigenvalues/variances used for the generation of the simulated functions based on            the truncated Karhunen-Loeve representation. See eVal for details.
#           N An integer, specifying the number of multivariate functions to be generated

#The following arguments are added:
#trueVals: Are the eigenvalues
#scores
```

```{r}
{
    if (!is.numeric(M)) 
        stop("Parameter 'M' must be numeric.")
    if (!is.character(eFunType)) 
        stop("Parameter 'eFunType' must be passed as a string.")
    if (!(is.null(ignoreDeg) | all(is.numeric(ignoreDeg), ignoreDeg > 
        0))) 
        stop("Parameter 'ignoreDeg' must be either NULL or a vector of positive numbers.")
        
    #if (!all(is.character(eValType), length(eValType) == 1)) 
    #    stop("Parameter 'eValType' must be passed as a string.")
        
    if (!all(is.numeric(N), length(N) == 1, N > 0)) 
        stop("Parameter 'N' must be passed as a positive number.")
    if (!(is.list(argvals) & all(is.numeric(unlist(argvals))))) {
        if (is.numeric(argvals)) 
            argvals <- list(argvals)
        else stop("Parameter 'argvals' must be either passed as a list or as a vector of numerics.")
    }
    
    if (Ph==TRUE) 
       if (length(ValPh) != N)
          stop("Length of the phase vector must be equal to the number of curves generated(N)")
    
    
    p <- length(argvals)
    if (length(M) != p) {
        if (length(M) == 1) {
            warning("Simulation of tensor product data. The value of M will be used for all dimensions.")
            M <- rep(M, p)
        }
        else stop("M must have the same length as argvals or 1.")
    }
    if (length(eFunType) != p) {
        if (length(eFunType) == 1) {
            warning("Simulation of tensor product data. The value of eFunType will be used for all dimensions.")
            eFunType <- rep(eFunType, p)
        }
        else stop("eFunType must have the same length as argvals or 1.")
    }
```

```{r}    
    #The scores are realizations of a multivariate normal with mean vector zero and covariance matriz given by diag(eigenvalues_j)
    #The eigenvalues (called trueVals int his code) constitute the variance of the scores
    #The following two lines are replaced by the arguments added to the function
    #These arguments store the eigenvalues and the scores of the spatial process
    
    #trueVals <- eVal(prod(M), eValType)
    #scores <- t(replicate(N, stats::rnorm(prod(M), sd = sqrt(trueVals))))
        
    if (p == 1) 
    {
      if(Ph==FALSE) # Curves WITHOUT PHASE. argvals is common for all the curves        
      {
         resX <- matrix(0, nrow=N, ncol= length(argvals[[1]]))
         argX <- matrix(0, nrow=N, ncol= length(argvals[[1]]))
         trueFuns <- eFunFreq(argvals = argvals[[1]], f=f, M = M, ignoreDeg = ignoreDeg, type = eFunType)
         for (j in 1:N) 
            resX[j,] <- t(as.matrix(scores[j,])) %*% trueFuns@X
         simData <- funData(argvals, resX)
      }
      else #Ph=TRUE. CURVES WITH PHASE. Each curve has its domain given by argvals
      {
         for (j in 1:N) 
         {
           trueFuns <- eFunFreq(argvals = argvals[[1]]+ValPh[j], f=f, M = M, ignoreDeg = ignoreDeg, type = eFunType)
           if (j==1)
           {
              argX <- list(argvals[[1]]+ValPh[j])
              resX <- list(as.numeric(t(as.matrix(scores[j,])) %*% trueFuns@X))
           }
           else
           {
              argX <- c(argX, list(argvals[[1]]+ValPh[j]))
              resX <- c(resX, list(as.numeric( t(as.matrix(scores[j,])) %*% trueFuns@X)))
           }
        }
        simData <- irregFunData(argX, resX)             
      }
    }
    return(list(simData = simData, trueFuns = trueFuns, trueVals = trueVals))
}
```

## Rutinas de simulación

```{r}
##Ejercicio 1. Graficar una distribuci?n normal multivariada. Simular una muestra (n=3),
#a partir de la muestra estimar media y varianza usar el estimador de MCG
```

```{r}    
##Ejercicio 2. Graficar una distribuci?n normal multivariada.Simular una muestra (n=300),
mu=5 # use um modelo autoregresivo continuo
#a partir de la muestra estimar media y varianza usar el estimador de MCG
```

```{r}    
x=seq(1,5,by=1)
y=x
grilla_1=expand.grid(x,y)
distancias_1=as.matrix(dist(grilla_1))
simulacion_1=rmultnorm(1, mu=rep(24,25), vmat=cov.spatial(distancias_1,cov.model="exp",cov.pars=c(2,3.5)))
simu_1=cbind(grilla_1,t(simulacion_1))
#Simulacion cholesky normal multivariada
#mu+L*x
coordenadas=matrix(c(1,2,3,2,5,7),nrow=3,byrow=T)
distancias=as.matrix(dist(coordenadas))
sigma=exp(-(distancias/4)^2)
#sigma=matrix(c(1,0.2,0.3,0.2,4,5,0.3,5,9),nrow=3,byrow=T)
U=chol(sigma)    #upper tambien llamada la raiz de Cholesky de sigmas
L=t(U)           #lower
#sigma=LU
#x=matrix(c(rnorm(3),rnorm(3),rnorm(3)),byrow=T,nrow=3)
#x=matrix(rnorm(6),byrow=T,nrow=3) #2 realizaciones normal de tres VA
x=matrix(rnorm(48),byrow=T,nrow=3)  #16 realizaciones de 3 variables q distribuyen conjuntamente normal con media mu y varianza sigma ''
x=matrix(rnorm(3000),byrow=T,nrow=3)  #1000 realizaciones ''
mu=c(3,4,39)
z=mu+L%*%x
apply(z,1,mean)
apply(z,1,var)
```

```{r}    
#simulacion descomposision espectral normal multivariada

#sigma=P*delta*P'    si sigma es simetrica existen P y delta, del a diagonal y P'P=I
#P'*sigma*P=delta
#P'*delta^0.5*P=sigma^0.5
```

```{r}    
vecprop=eigen(sigma)
P=vecprop$vectors
delta=t(P)%*%sigma%*%P    #la diagonal de delta son los valores propios
raiz_sigma=t(P)%*%round(delta,2)^(1/2)%*%P  #me toca redondear por aparecen unos valores -1.55*10E-15 que es aprox 0 pero -
z=mu+L%*%raiz_sigma
```

```{r}    
#descomposicion en valor singular, es igual al espectrral solo q trabaja con los eigen de sigma'sigma porq es general para cualquier matriz nxm y los valores propios de sigma'sigma son el cuadrado de los de sigma
singular=svd(sigma)
s=diag(singular$d)
(singular$u)%*%s%*%t(singular$v)
#sigma=(singular$u)%*%s%*%(t(singular$v))
library(mvtnorm)
norm_m <- rmvnorm(n=500, mean=c(1,2), sigma=sigma, method="chol")
??mvtnorm
```

```{r}    
#simulacion condicional
#secuencial gaussiana
library(gstat)
data(meuse)
meuse1=meuse[1:5,]  #tome los primeros para ver la salida y comparar
coordinates(meuse1) = ~x+y 
data(meuse.grid)
meuse.grid1=meuse.grid[1:5]
meuse.grid1=meuse.grid[1:5,]
coordinates(meuse.grid1)=~x + y
m=vgm(1,"Gau",150)
x <- krige(log(zinc)~1, meuse1, meuse.grid1, model = m)
x1 <- krige(log(zinc)~1, meuse1, meuse.grid1, model = m, block = c(40,40))
x3 <- krige(log(zinc)~1, meuse1, meuse.grid1, model = m,nsim=2)  #simulacion secuencial gaussiana
#si se usa el gstat para la simulacion gaussiana y se quiere hacer uno por uno, solo es simular el primer lugar,
# incluirlo en los datos observados y luego simular el segundo y asi...
```

```{r}    
#simular datos de un proceso con cov gaussiana para ver como son las ponderaciones
#grilla en F:/Patricia/Escritorio/revisar
potasio1=read.table("potasio.txt",head=T)
coorde=cbind(potasio1$x,potasio1$y) #solo las coordenadas
distancias=as.matrix(dist(coorde))  #matriz de distancias 
sigma=exp(-(distancias/8)^2)      #matriz de covarianzas    
U=chol(sigma)    #upper tambien llamada la raiz de Cholesky de sigmas
L=t(U)
x=matrix(rnorm(95),byrow=F,nrow=95)
z_sim=t(U)%*%x          #supongamos mu=0
potasio2=data.frame(potasio1$x,potasio1$y,z_sim)
potasio3=potasio2
pot2g=as.geodata(potasio2)
v1=variog(pot2g)
plot(v1)
v2=variofit(pot2g,ini=inic)
coordinates(potasio3)=~potasio1.x+potasio1.y
loci <- expand.grid(seq(5,10,len=5), seq(0,30,len=4))
coordinates(loci)=~Var1+Var2
v3=as.vgm.variomodel(v2)
krige(z_sim~1, potasio3, loci, model = v3)
kc <- krige.conv(pot2g,locations=loci,krige=modelo)
```

```{r}    
modelo<-krige.control(obj.model=v2)
```

## Simulación eigenfunctions

```{r}

u2=function(x) {(sqrt(2/2)*cos(2*2*x*pi/2))}
u3=function(x) {(sqrt(2/2)*cos(2*3*x*pi/2))}
curve(v1,-1,1,xlab=expression(italic(t)),ylab="",cex.lab=1.5,cex.axis=1.2)
curve(v2,-1,1,add=T,ylab="",cex.lab=1.5,cex.axis=1.2,col=2)
curve(v3,-1,1,add=T,ylab="",cex.lab=1.5,cex.axis=1.2,col=3)
```

```{r} 
integrand <- function(x) {(sin(pi*x/2))^2}
integrate(integrand, lower = 0, upper =1)
integrand <- function(x) {(cos(pi*x/2))^2}
integrate(integrand, lower = 0, upper =1)
integrand <- function(x) {(sin(pi*x/2))*(cos(pi*x/2))}
integrate(integrand, lower = 0, upper =1)
```

```{r} 
integrand <- function(x) {(sin(pi*x/2))*(cos(pi*x/2))}
integrate(integrand, lower = -1, upper =1)
```

```{r} 
curve(u1,-1,1,xlab=expression(italic(t)),ylab="",cex.lab=1.5,cex.axis=1.2)
curve(u2,-1,1,add=T,ylab="",cex.lab=1.5,cex.axis=1.2,col=5)
curve(u3,-1,1,add=T,ylab="",cex.lab=1.5,cex.axis=1.2,col=6)
```

```{r} 
##############En L2[-1,1] n=1
integrand <- function(x) {(sqrt(2/2)*sin(2*1*x*pi/2))^2}
integrate(integrand, lower = -1, upper =1)
##En L2[-1,1] n=2
integrand <- function(x) {(sqrt(2/2)*sin(2*2*x*pi/2))^2}
integrate(integrand, lower = -1, upper =1)
##En L2[-1,1] n=3
integrand <- function(x) {(sqrt(2/2)*sin(2*3*x*pi/2))^2}
integrate(integrand, lower = -1, upper =1)
```

```{r} 
###########coseno verificando que todos tienen norma 1
coseno_Fourier=function(x,n,L){sqrt(2/L)*cos(n*pi*x/L)}
##En L2[-1,1] n=1
integrand <- function(x) {(sqrt(2/2)*cos(2*1*x*pi/2))^2}
integrate(integrand, lower = -1, upper =1)
##En L2[-1,1] n=2
integrand <- function(x) {(sqrt(2/2)*cos(2*2*x*pi/2))^2}
integrate(integrand, lower = -1, upper =1)
##En L2[-1,1] n=3
integrand <- function(x) {(sqrt(2/2)*cos(2*3*x*pi/2))^2}
integrate(integrand, lower = -1, upper =1)
##En L2[-1,1] n=4
integrand <- function(x) {(sqrt(2/2)*cos(2*4*x*pi/2))^2}
integrate(integrand, lower = -1, upper =1)
```

```{r} 
###### verificando que todos son ortogonales
integrand <- function(x) {(sqrt(2/2)*cos(2*2*x*pi/2))*(sqrt(2/2)*sin(2*2*x*pi/2))}
integrate(integrand, lower = -1, upper =1)
integrand <- function(x) {(sqrt(2/2)*cos(2*2*x*pi/2))*(sqrt(2/2)*cos(2*3*x*pi/2))}
integrate(integrand, lower = -1, upper =1)
integrand <- function(x) {(sqrt(2/2)*sin(2*1*x*pi/2))*(sqrt(2/2)*sin(2*2*x*pi/2))}
integrate(integrand, lower = -1, upper =1)
```

```{r} 
##################Legendre ver conway pag18 ejercicio 6, L^2[-1,1]
v1=function(x){sqrt(1/2)}
v2=function(x){x*sqrt(3/2)}
v3=function(x){(sqrt(5/2))*(1/8)*(12*x^2-4)}
v4=function(x){(5/2)*(sqrt(7/2))*(-(3*x/5)+x^3)}
#Ejemplo 0.005*5sqrt(1/2)+0.05*v2(x)+0.5*v3(x)+7*v4(x)
```

```{r} 
curve(v2,-1,1,xlab=expression(italic(t)),ylab="",cex.lab=1.5,cex.axis=1.2)
curve(v3,-1,1,add=T,ylab="",cex.lab=1.5,cex.axis=1.2,col=2)
curve(v4,-1,1,add=T,ylab="",cex.lab=1.5,cex.axis=1.2,col=3)
```

```{r} 
##Verificando norma uno v2
integrand <- function(x){((5/2)*(sqrt(7/2))*(-(3*x/5)+x^3))^2}
integrate(integrand, lower = -1, upper =1)
```

```{r} 
integrand <- function(x){(x*sqrt(3/2))^2}
integrate(integrand, lower = -1, upper =1)
```

```{r} 
##Verificando norma uno v3
integrand <- function(x){((sqrt(5/2))*(1/8)*(12*x^2-4))^2}
integrate(integrand, lower = 0, upper =1)
```

```{r} 
##Verificando norma uno v4
integrand <- function(x){(x*sqrt(3/2))*((sqrt(5/2))*(1/8)*(12*x^2-4))}
integrate(integrand, lower = 0, upper =1)
```

```{r} 
##Verificando ortogonalidad v2 v3
integrand <- function(x){(((x*sqrt(3/2)))*((sqrt(5/2))*(1/8)*(12*x^2-4)))}
integrate(integrand, lower = -1, upper =1)
```

```{r} 
##Verificando ortogonalidad v2 v4
integrand <- function(x){((x*sqrt(3/2)))*((5/2)*(sqrt(7/2))*(-(3*x/5)+x^3))}
integrate(integrand, lower = 0, upper =1)
```

```{r} 
##Verificando ortogonalidad v3 v4
integrand <- function(x){((sqrt(5/2))*(1/8)*(12*x^2-4))*((5/2)*(sqrt(7/2))*(-(3*x/5)+x^3))}
integrate(integrand, lower = -1, upper =1)
```

```{r} 
##Chebyshev
v1=function(x){(sqrt(3/2)*x)}
v2=function(x){(sqrt(15/14))*cos(2*acos(x))}
v3=function(x){sqrt(1/0.9714286)*cos(3*acos(x))}
##Verificando ortogonalidad v1 v2
```

```{r} 
curve(v2,-1,1,xlab=expression(italic(t)),ylab="",cex.lab=1.5,cex.axis=1.2)
curve(v3,-1,1,add=T,ylab="",cex.lab=1.5,cex.axis=1.2,col=2)
curve(v4,-1,1,add=T,ylab="",cex.lab=1.5,cex.axis=1.2,col=3)
```

```{r} 
######norma v1
integrand <- function(x){((sqrt(3/2))*x)^2}
integrate(integrand, lower = -1, upper =1)
```

```{r} 
######norma v2
integrand <- function(x){((sqrt(15/14))*cos(2*acos(x)))^2}
integrate(integrand, lower = -1, upper =1)
```

```{r} 
######norma v3
integrand <- function(x){(sqrt(1/0.9714286)*cos(3*acos(x)))^2}
integrate(integrand, lower = -1, upper =1)
```

```{r} 
###### v1 v2
integrand <- function(x){(sqrt(3/2)*x)*((sqrt(15/14))*cos(2*acos(x)))}
integrate(integrand, lower = -1, upper =1)
```

```{r} 

###### v1 v3
integrand <- function(x){(sqrt(3/2)*x)*(sqrt(1/0.9714286)*cos(3*acos(x)))}
integrate(integrand, lower = -1, upper =1)
```

```{r} 
###### v2 v3
integrand <- function(x){(sqrt(1/0.9714286)*cos(3*acos(x)))*((sqrt(15/14))*cos(2*acos(x)))}
integrate(integrand, lower = -1, upper =1)
```

```{r} 
#############Simulaciones scores
library(MSBVAR)
x=runif(25,0,1)
y=runif(25,0,1)
grilla=data.frame(x,y)
plot(grilla,xlab=expression(italic(x)),ylab=expression(italic(y)),cex.lab=1.2,cex.axis=1.2)
sigma_t=function(t){0.1*t}
b_t=function(t){0.15*t}
exp_esp=function(sigma,h){((sigma)^2)*exp(-h/0.8)}
Gaus_esp=function(sigma,h){((sigma)^2)*exp(-h^2/0.8)}
Sph_esp1=function(sigma,h){ifelse(h<=0.9,((sigma)^2)*(1-1.5*(h/0.9)+0.5*h^3/(0.9^3)),0)}
Sph_esp2=function(sigma,h){ifelse(h<=0.5,((sigma)^2)*(1-1.5*(h/0.5)+0.5*h^3/(0.5^3)),0)}
```

```{r} 
grilla=read.table("grilla.txt")
#t el n?mero total de tiempo a ser simulado se puede dar como parametro t=1:Nt, grilla las n ubicaciones a ser simuladas
mu=rep(0,25)
#f11
h=as.matrix(dist(grilla))
vmat=exp_esp(5,h)+Sph_esp2(3,h)
f11=rmultnorm(1,mu=mu,vmat=vmat)
```

```{r} 
#f22
h=as.matrix(dist(grilla))
vmat=exp_esp(4,h)+Sph_esp2(1,h)
f22=rmultnorm(1,mu=mu,vmat=vmat)
```

```{r} 
#f12
h=as.matrix(dist(grilla))
vmat=exp_esp(4,h)+Sph_esp2(1,h)
f12=rmultnorm(1,mu=mu,vmat=vmat)
```

```{r} 
#f23
h=as.matrix(dist(grilla))
vmat=exp_esp(4,h)+Sph_esp2(1,h)
f23=rmultnorm(1,mu=mu,vmat=vmat)
```

```{r} 
mu=rep(0,25)
curve(exp_esp(5,x),ylim=c(-2,40))
curve(Sph_esp2(2,x),add=T,col=2)
curve(exp_esp(5,x)+Sph_esp2(3,x),add=T,col=3)
curve(Sph_esp2(3,x),col=2,add=T)
Sim_Cov_t=function(modelo,grilla)
{simulados=data.frame()
 h=as.matrix(dist(grilla))
 simulados=rbind(simulados,data.frame(grilla,t(rmultnorm(1, mu=mu,vmat=modelo(10,h)))))
 colnames(simulados)=c("x","y","Z")
 simulados
} 
```

```{r} 
curve(f11[1]*v3(x)+f22[1]*v4(x),-1,1,ylim=c(-5,5))
curve(f11[i]*v4(x),add=T)
curve(f11[2]*(sqrt(7/2))*(-(3*x/5)+x^3),add=T)

curve(-(3*x/5)+x^3,add=T) # jocastroc asumi que faltaba curve
x=seq(-1,1,len=250)
#for(i in 1:25)
dato1f11=(f11[1]*v2(x)+f12[1]*v3(x)+f23[1]*v4(x))
dato2f11=(f11[2]*v2(x)+f12[2]*v3(x)+f23[2]*v4(x))
dato3f11=(f11[3]*v2(x)+f12[3]*v3(x)+f23[3]*v4(x))
dato4f11=(f11[4]*v2(x)+f12[4]*v3(x)+f23[4]*v4(x))
dato5f11=(f11[5]*v2(x)+f12[5]*v3(x)+f23[5]*v4(x))
dato6f11=(f11[6]*v2(x)+f12[6]*v3(x)+f23[6]*v4(x))
dato7f11=(f11[7]*v2(x)+f12[7]*v3(x)+f23[7]*v4(x))
dato8f11=(f11[8]*v2(x)+f12[8]*v3(x)+f23[8]*v4(x))
dato9f11=(f11[9]*v2(x)+f12[9]*v3(x)+f23[9]*v4(x))
dato10f11=(f11[10]*v2(x)+f12[10]*v3(x)+f23[10]*v4(x))
dato11f11=(f11[11]*v2(x)+f12[11]*v3(x)+f23[11]*v4(x))
dato12f11=(f11[12]*v2(x)+f12[12]*v3(x)+f23[12]*v4(x))
dato13f11=(f11[13]*v2(x)+f12[13]*v3(x)+f23[13]*v4(x))
dato14f11=(f11[14]*v2(x)+f12[14]*v3(x)+f23[14]*v4(x))
dato15f11=(f11[15]*v2(x)+f12[15]*v3(x)+f23[15]*v4(x))
dato16f11=(f11[16]*v2(x)+f12[16]*v3(x)+f23[16]*v4(x))
dato17f11=(f11[17]*v2(x)+f12[17]*v3(x)+f23[17]*v4(x))
dato18f11=(f11[18]*v2(x)+f12[18]*v3(x)+f23[18]*v4(x))
dato19f11=(f11[19]*v2(x)+f12[19]*v3(x)+f23[19]*v4(x))
dato20f11=(f11[20]*v2(x)+f12[20]*v3(x)+f23[20]*v4(x))
dato21f11=(f11[21]*v2(x)+f12[21]*v3(x)+f23[21]*v4(x))
dato22f11=(f11[22]*v2(x)+f12[22]*v3(x)+f23[22]*v4(x))
dato23f11=(f11[23]*v2(x)+f12[23]*v3(x)+f23[23]*v4(x))
dato24f11=(f11[24]*v2(x)+f12[24]*v3(x)+f23[24]*v4(x))
dato25f11=(f11[25]*v2(x)+f12[25]*v3(x)+f23[25]*v4(x))
```

```{r} 
datosf11=data.frame(dato1f11,dato2f11,dato3f11,dato4f11,dato5f11,dato6f11,dato7f11,dato8f11,dato9f11,dato10f11,
                    dato11f11,dato12f11,dato13f11,dato14f11,dato15f11,dato16f11,dato17f11,dato18f11,dato19f11,dato20f11,
                    dato21f11,dato22f11,dato23f11,dato24f11,dato25f11)
```

```{r} 
datosf11=data.frame(dato1f11+runif(250,-5,5),dato2f11+runif(250,-5,5),dato3f11+runif(250,5,5),dato4f11+runif(250,-5,5),dato5f11+runif(250,-5,5),
dato6f11+runif(250,-5,5),dato7f11+runif(250,-5,5),dato8f11+runif(250,-5,5),dato9f11+runif(250,-5,5),dato10f11+runif(250,-5,5),
                    dato11f11+runif(250,-5,5),dato12f11+runif(250,-5,5),dato13f11+runif(250,-5,5),dato14f11+runif(250,-5,5),dato15f11+runif(250,-5,5),
dato16f11+runif(250,-5,5),dato17f11+runif(250,-5,5),dato18f11+runif(250,-5,5),dato19f11+runif(250,-5,5),dato20f11+runif(250,-5,5),
                    dato21f11+runif(250,-5,5),dato22f11+runif(250,-5,5),dato23f11+runif(250,-5,5),dato24f11+runif(250,-5,5),dato25f11+runif(250,-5,5))
```

```{r} 

datosf11=data.frame(dato1f11+runif(250,-7,7),dato2f11+runif(250,-7,7),dato3f11+runif(250,-7,7),dato4f11+runif(250,-7,7),dato5f11+runif(250,-7,7),
dato6f11+runif(250,-7,7),dato7f11+runif(250,-7,7),dato8f11+runif(250,-7,7),dato9f11+runif(250,-7,7),dato10f11+runif(250,-7,7),
                    dato11f11+runif(250,-7,7),dato12f11+runif(250,-7,7),dato13f11+runif(250,-7,7),dato14f11+runif(250,-7,7),dato15f11+runif(250,-7,7),
dato16f11+runif(250,-7,7),dato17f11+runif(250,-7,7),dato18f11+runif(250,-7,7),dato19f11+runif(250,-7,7),dato20f11+runif(250,-7,7),
                    dato21f11+runif(250,-7,7),dato22f11+runif(250,-7,7),dato23f11+runif(250,-7,7),dato24f11+runif(250,-7,7),dato25f11+runif(250,-7,7))
```

```{r} 
datosTT=ts(datosf11)
plot(datosTT)
library(fda.usc)
Mdatosf11=as.matrix(datosf11,nrow=50,ncol=25)
#ID_estaciones=c("1","2","3","4","5","6","7","8","9")
datosf=fdata(Mdatosf11,argvals=1:nrow(Mdatosf11))
nbasis <-459
hourange <- c(1,nrow(Mdatosf11))
lambda=0.0000001
harmaccelLfd <- vec2Lfd(c(1,15), hourange)
hourbasis_Bsplines <- create.bspline.basis(hourange,nbasis)
PM10_fdPar_Bspline_sim<-fdPar(fdobj=hourbasis_Bsplines,Lfdobj=harmaccelLfd,lambda)
PM10_fd_Bspline_sim <- smooth.basis(argvals=1:nrow(Mdatosf11),Mdatosf11,PM10_fdPar_Bspline_sim)
PM10_fd_Bspl_sim=PM10_fd_Bspline_sim$fd
plot(PM10_fd_Bspl_sim[-3],ylim=c(-12,12),xlim=c(6,245),lty=1,lwd=2,cex=1,col=rainbow(25),ylab="",xlab="Time",cex.lab=1.2,cex.axis=1.2,main="Simulated data")
#lines(PM10_fd_Bspl,col=rainbow(25),lwd=2,lty=1)
#title(ylab=expression(chi[s]^1),cex.lab=1.2,mgp=c(2.5,0,0))
loc <- par("usr")
text(loc[1.5], loc[4.3], adj = c(2.5,4),expression(bold(chi)[s]^1),xpd = T,cex=2)
```

```{r} 
x11()
Mdatosf11pred=as.matrix(datosf11Pred,nrow=50,ncol=25)
#ID_estaciones=c("1","2","3","4","5","6","7","8","9")
datosf=fdata(Mdatosf11pred,argvals=1:nrow(Mdatosf11pred))
nbasis <-99
hourange <- c(1,nrow(Mdatosf11pred))
lambda=0.001
harmaccelLfd <- vec2Lfd(c(1,10), hourange)
hourbasis_Bsplines <- create.bspline.basis(hourange,nbasis)
PM10_fdPar_Bspline<-fdPar(fdobj=hourbasis_Bsplines,Lfdobj=harmaccelLfd,lambda)
PM10_fd_Bspline <- smooth.basis(argvals=1:nrow(Mdatosf11pred),Mdatosf11pred,PM10_fdPar_Bspline)
PM10_fd_Bspl=PM10_fd_Bspline$fd
plot(PM10_fd_Bspl,ylim=c(-9,9),xlim=c(5,45),col=rainbow(25),lty=1,lwd=2,cex=1,ylab="",xlab="Time",cex.lab=1.2,cex.axis=1.2,main="Functional cokriging")
#lines(PM10_fd_Bspl,col=rainbow(25),lwd=2,lty=1)
#title(ylab=expression(bold(chi)[s]^1),cex.lab=1.2,mgp=c(2.5,0,0))
loc <- par("usr")
text(loc[1.5], loc[4.3], adj = c(2.5,4),expression(bold(chi)[s]^1),xpd = T,cex=2)

x11()
plot(PM10_fd_Bspl[7]-PM10_fd_Bspl_sim[7],ylim=c(-1.5,1.5),xlim=c(5,45),col=7,lty=1,lwd=2,cex=1,ylab="",xlab="Time",cex.lab=1.2,cex.axis=1.2)
lines(PM10_fd_Bspl[2]-PM10_fd_Bspl_sim[2],ylim=c(-2,2),xlim=c(5,45),col=2,lty=1,lwd=2,cex=1,ylab="",xlab="Time",cex.lab=1.2,cex.axis=1.2)
lines(PM10_fd_Bspl[4]-PM10_fd_Bspl_sim[4],ylim=c(-2,2),xlim=c(5,45),col=4,lty=1,lwd=2,cex=1,ylab="",xlab="Time",cex.lab=1.2,cex.axis=1.2)
lines(PM10_fd_Bspl[5]-PM10_fd_Bspl_sim[5],ylim=c(-2,2),xlim=c(5,45),col=5,lty=1,lwd=2,cex=1,ylab="",xlab="Time",cex.lab=1.2,cex.axis=1.2)
lines(PM10_fd_Bspl[6]-PM10_fd_Bspl_sim[6],ylim=c(-2,2),xlim=c(5,45),col=6,lty=1,lwd=2,cex=1,ylab="",xlab="Time",cex.lab=1.2,cex.axis=1.2)
loc <- par("usr")
text(loc[1.5], loc[4.3], adj = c(2.5,4),expression(bold(chi[pred])[s]^1),xpd = T,cex=2)
```

```{r} 
x11()
plot(PM10_fd_Bspl[1]-PM10_fd_Bspl_sim[1],ylim=c(-4,4),xlim=c(5,45),col=8,lty=1,lwd=2,cex=1,ylab="",xlab="Time",cex.lab=1.2,cex.axis=1.2,main="Residual functions")
lines(PM10_fd_Bspl[2]-PM10_fd_Bspl_sim[2],ylim=c(-2,2),xlim=c(5,45),col=2,lty=1,lwd=2,cex=1,ylab="",xlab="Time",cex.lab=1.2,cex.axis=1.2)
lines(PM10_fd_Bspl[3]-PM10_fd_Bspl_sim[3],ylim=c(-2,2),xlim=c(5,45),col=3,lty=1,lwd=2,cex=1,ylab="",xlab="Time",cex.lab=1.2,cex.axis=1.2)
lines(PM10_fd_Bspl[4]-PM10_fd_Bspl_sim[4],ylim=c(-2,2),xlim=c(5,45),col=4,lty=1,lwd=2,cex=1,ylab="",xlab="Time",cex.lab=1.2,cex.axis=1.2)
lines(PM10_fd_Bspl[5]-PM10_fd_Bspl_sim[5],ylim=c(-2,2),xlim=c(5,45),col=5,lty=1,lwd=2,cex=1,ylab="",xlab="Time",cex.lab=1.2,cex.axis=1.2)
lines(PM10_fd_Bspl[6]-PM10_fd_Bspl_sim[6],ylim=c(-2,2),xlim=c(5,45),col=6,lty=1,lwd=2,cex=1,ylab="",xlab="Time",cex.lab=1.2,cex.axis=1.2)
lines(PM10_fd_Bspl[7]-PM10_fd_Bspl_sim[7],ylim=c(-2,2),xlim=c(5,45),col=7,lty=1,lwd=2,cex=1,ylab="",xlab="Time",cex.lab=1.2,cex.axis=1.2)
lines(PM10_fd_Bspl[8]-PM10_fd_Bspl_sim[8],ylim=c(-2,2),xlim=c(5,45),col=8,lty=1,lwd=2,cex=1,ylab="",xlab="Time",cex.lab=1.2,cex.axis=1.2)
#lines(PM10_fd_Bspl[9]-PM10_fd_Bspl_sim[9],ylim=c(-2,2),xlim=c(5,45),col="grey",lty=1,lwd=2,cex=1,ylab="",xlab="Time",cex.lab=1.2,cex.axis=1.2)
loc <- par("usr")
text(loc[1.5], loc[4.3], adj = c(2.5,4),expression(bold(chi[pred])[s]^1),xpd = T,cex=2)
legend("topleft",legend=1:8,lwd=2.5,cex=1,col=1:8,horiz=T,seg.len=1.1)
```

```{r} 
x11()
plot(PM10_fd_Bspl_sim[15],ylim=c(-15,11),xlim=c(5,45),col=1,lty=1,lwd=2,cex=1,ylab="",xlab="Time",cex.lab=1.2,cex.axis=1.2)
lines(PM10_fd_Bspl[15],ylim=c(-1,1),xlim=c(5,45),col=2,lty=1,lwd=2,cex=1,ylab="",xlab="Time",cex.lab=1.2,cex.axis=1.2)
loc <- par("usr")
text(loc[1.5], loc[4.3], adj = c(1.6,4),expression(bold(chi)[s[15]]^1),xpd = T,cex=2)
legend("topleft",legend=c("Simulated", "Prediction"),lwd=2.5,cex=1.2,col=1:2,horiz=T,seg.len=2)
```

```{r} 
x11()
datosTT=ts(datosf11)
ts.plot(datosTT,col=rainbow(25),ylim=c(-20,20),xlim=c(6,45),type="l")
###########################################################################
f22
h=as.matrix(dist(grilla))
vmat=exp_esp(4,h)+Sph_esp2(1,h)
f22=rmultnorm(1,mu=mu,vmat=vmat)
```

```{r} 
curve(exp_esp(5,x),ylim=c(-2,40))
curve(Sph_esp2(2,x),add=T,col=2)
curve(exp_esp(5,x)+Sph_esp2(3,x),add=T,col=3)
curve(Sph_esp2(3,x),col=2,add=T)
Sim_Cov_t=function(modelo,grilla)
{simulados=data.frame()
 h=as.matrix(dist(grilla))
 simulados=rbind(simulados,data.frame(grilla,t(rmultnorm(1, mu=mu,vmat=modelo(10,h)))))
 colnames(simulados)=c("x","y","Z")
 simulados
} 
```

```{r} 
curve(f11[1]*v3(x)+f22[1]*v4(x),-1,1,ylim=c(-5,5))
curve(f11[i]*v4(x),add=T)
curve(f11[2]*(sqrt(7/2))*(-(3*x/5)+x^3),add=T)
x=seq(-1,1,len=250)
#for(i in 1:25)
dato1f22=(f22[1]*v2(x)+f12[1]*v3(x)+f23[1]*v4(x))*rnorm(250)
dato2f22=(f22[2]*v2(x)+f12[2]*v3(x)+f23[2]*v4(x))*rnorm(250)
dato3f22=(f22[3]*v2(x)+f12[3]*v3(x)+f23[3]*v4(x))*rnorm(250)
dato4f22=(f22[4]*v2(x)+f12[4]*v3(x)+f23[4]*v4(x))*rnorm(250)
dato5f22=(f22[5]*v2(x)+f12[5]*v3(x)+f23[5]*v4(x))*rnorm(250)
dato6f22=(f22[6]*v2(x)+f12[6]*v3(x)+f23[6]*v4(x))*rnorm(250)
dato7f22=(f22[7]*v2(x)+f12[7]*v3(x)+f23[7]*v4(x))*rnorm(250)
dato8f22=(f22[8]*v2(x)+f12[8]*v3(x)+f23[8]*v4(x))*rnorm(250)
dato9f22=(f22[9]*v2(x)+f12[9]*v3(x)+f23[9]*v4(x))*rnorm(250)
dato10f22=(f22[10]*v2(x)+f12[10]*v3(x)+f23[10]*v4(x))*rnorm(250)
dato11f22=(f22[11]*v2(x)+f12[11]*v3(x)+f23[11]*v4(x))*rnorm(250)
dato12f22=(f22[12]*v2(x)+f12[12]*v3(x)+f23[12]*v4(x))*rnorm(250)
dato13f22=(f22[13]*v2(x)+f12[13]*v3(x)+f23[13]*v4(x))*rnorm(250)
dato14f22=(f22[14]*v2(x)+f12[14]*v3(x)+f23[14]*v4(x))*rnorm(250)
dato15f22=(f22[15]*v2(x)+f12[15]*v3(x)+f23[15]*v4(x))*rnorm(250)
dato16f22=(f22[16]*v2(x)+f12[16]*v3(x)+f23[16]*v4(x))*rnorm(250)
dato17f22=(f22[17]*v2(x)+f12[17]*v3(x)+f23[17]*v4(x))*rnorm(250)
dato18f22=(f22[18]*v2(x)+f12[18]*v3(x)+f23[18]*v4(x))*rnorm(250)
dato19f22=(f22[19]*v2(x)+f12[19]*v3(x)+f23[19]*v4(x))*rnorm(250)
dato20f22=(f22[20]*v2(x)+f12[20]*v3(x)+f23[20]*v4(x))*rnorm(250)
dato21f22=(f22[21]*v2(x)+f12[21]*v3(x)+f23[21]*v4(x))*rnorm(250)
dato22f22=(f22[22]*v2(x)+f12[22]*v3(x)+f23[22]*v4(x))*rnorm(250)
dato23f22=(f22[23]*v2(x)+f12[23]*v3(x)+f23[23]*v4(x))*rnorm(250)
dato24f22=(f22[24]*v2(x)+f12[24]*v3(x)+f23[24]*v4(x))*rnorm(250)
dato25f22=(f22[25]*v2(x)+f12[25]*v3(x)+f23[25]*v4(x))*rnorm(250)
```

```{r} 
datosf22=data.frame(dato1f22,dato2f22,dato3f22,dato4f22,dato5f22,dato6f22,dato7f22,dato8f22,dato9f22,dato10f22,
                    dato11f22,dato12f22,dato13f22,dato14f22,dato15f22,dato16f22,dato17f22,dato18f22,dato19f22,dato20f22,
                    dato21f22,dato22f22,dato23f22,dato24f22,dato25f22)
datosTT=tseries(datosf22)
```

```{r} 
Mdatosf22=as.matrix(datosf22,nrow=50,ncol=25)
#ID_estaciones=c("1","2","3","4","5","6","7","8","9")
datosf=fdata(Mdatosf22,argvals=1:nrow(Mdatosf22))
nbasis <-1501
hourange <- c(1,nrow(Mdatosf22))
lambda=0.000001
harmaccelLfd <- vec2Lfd(c(1,10), hourange)
hourbasis_Bsplines <- create.bspline.basis(hourange,nbasis)
PM10_fdPar_Bspline<-fdPar(fdobj=hourbasis_Bsplines,Lfdobj=harmaccelLfd,lambda)
PM10_fd_Bspline <- smooth.basis(argvals=1:nrow(Mdatosf22),Mdatosf22,PM10_fdPar_Bspline)
PM10_fd_Bspl=PM10_fd_Bspline$fd
plot(PM10_fd_Bspl,ylim=c(-22,22),xlim=c(6,50),col=rainbow(25),lty=1,lwd=2,cex=1,ylab="",xlab="Time",cex.lab=1.2,cex.axis=1.2,main="Simulated data")
#lines(PM10_fd_Bspl,col=rainbow(25),lwd=2,lty=1)
#title(ylab=expression(chi[s]^1),cex.lab=1.2,mgp=c(2.5,0,0))
loc <- par("usr")
text(loc[1.5], loc[4.3], adj = c(2.5,4),expression(bold(chi)[s]^2),xpd = T,cex=2)
```

```{r} 
x11()
datosTT=ts(datosf11)
ts.plot(datosTT,col=rainbow(25),ylim=c(-20,20),xlim=c(6,45),type="l")
```

```{r} 
dato1=(f22[1]*v2(x)+f12[1]*v4(x)+f11[1]*v3(x))*rnorm(250)
dato2=(f22[2]*v2(x)+f11[2]*v3(x)+f12[2]*v4(x))*rnorm(250)
dato3=(f22[3]*v2(x)+f11[3]*v3(x)+f12[3]*v4(x))*rnorm(250)
dato4=(f22[4]*v2(x)+f11[4]*v3(x)+f12[4]*v4(x))*rnorm(250)
dato5=(f22[5]*v2(x)+f11[5]*v3(x)+f12[5]*v4(x))*rnorm(250)
dato6=(f22[6]*v2(x)+f11[6]*v3(x)+f12[6]*v4(x))*rnorm(250)
dato7=(f22[7]*v2(x)+f11[7]*v3(x)+f12[7]*v4(x))*rnorm(250)
dato8=(f22[8]*v2(x)+f11[8]*v3(x)+f12[8]*v4(x))*rnorm(250)
dato9=(f22[9]*v2(x)+f11[9]*v3(x)+f12[9]*v4(x))*rnorm(250)
dato10=(f22[10]*v2(x)+f11[10]*v3(x)+f12[10]*v4(x))*rnorm(250)
dato11=(f22[11]*v2(x)+f11[11]*v3(x)+f12[11]*v4(x))*rnorm(250)
dato12=(f22[12]*v2(x)+f11[12]*v3(x)+f12[12]*v4(x))*rnorm(250)
dato13=(f22[13]*v2(x)+f11[13]*v3(x)+f12[13]*v4(x))*rnorm(250)
dato14=(f22[14]*v2(x)+f11[14]*v3(x)+f12[14]*v4(x))*rnorm(250)
dato15=(f22[15]*v2(x)+f11[15]*v3(x)+f12[15]*v4(x))*rnorm(250)
dato16=(f22[16]*v2(x)+f11[16]*v3(x)+f12[16]*v4(x))*rnorm(250)
dato17=(f22[17]*v2(x)+f11[17]*v3(x)+f12[17]*v4(x))*rnorm(250)
dato18=(f22[18]*v2(x)+f11[18]*v3(x)+f12[18]*v4(x))*rnorm(250)
dato19=(f22[19]*v2(x)+f11[19]*v3(x)+f12[19]*v4(x))*rnorm(250)
dato20=(f22[20]*v2(x)+f11[20]*v3(x)+f12[20]*v4(x))*rnorm(250)
dato21=(f22[21]*v2(x)+f11[21]*v3(x)+f12[21]*v4(x))*rnorm(250)
dato22=(f22[22]*v2(x)+f11[22]*v3(x)+f12[22]*v4(x))*rnorm(250)
dato23=(f22[23]*v2(x)+f11[23]*v3(x)+f12[23]*v4(x))*rnorm(250)
dato24=(f22[24]*v2(x)+f11[24]*v3(x)+f12[24]*v4(x))*rnorm(250)
dato25=(f22[25]*v2(x)+f11[25]*v3(x)+f12[25]*v4(x))*rnorm(250)
```

```{r} 

datos=data.frame(dato1,dato2,dato3,dato4,dato5,dato6,dato7,dato8,dato9,dato10,
                    dato11,dato12,dato13,dato14,dato15,dato16,dato17,dato18,dato19,dato20,
                    dato21,dato22,dato23,dato24,dato25)
datosTT=tseries(datos)
```

```{r} 
Mdatos=as.matrix(datos,nrow=50,ncol=25)
#ID_estaciones=c("1","2","3","4","5","6","7","8","9")
datosf=fdata(Mdatos,argvals=1:nrow(Mdatos))
nbasis <-250
hourange <- c(1,nrow(Mdatos))
lambda=0.000001
harmaccelLfd <- vec2Lfd(c(1,10), hourange)
hourbasis_Bsplines <- create.bspline.basis(hourange,nbasis)
PM10_fdPar_Bspline<-fdPar(fdobj=hourbasis_Bsplines,Lfdobj=harmaccelLfd,lambda)
PM10_fd_Bspline <- smooth.basis(argvals=1:nrow(Mdatosf22),Mdatosf22,PM10_fdPar_Bspline)
PM10_fd_Bspl=PM10_fd_Bspline$fd
plot(PM10_fd_Bspl,ylim=c(-29,24),xlim=c(6,50),col=rainbow(25),lty=1,lwd=2,cex=1,ylab="",xlab="Time",cex.lab=1.2,cex.axis=1.2,main="Functional cokriging")
#lines(PM10_fd_Bspl,col=rainbow(25),lwd=2,lty=1)
#title(ylab=expression(chi[s]^1),cex.lab=1.2,mgp=c(2.5,0,0))
loc <- par("usr")
text(loc[1.5], loc[4.3], adj = c(2.5,4),expression(bold(chi)[s]^1),xpd = T,cex=2)
```

```{r} 
x11()
plot(PM10_fd_Bspl_sim-PM10_fd_Bspl,ylim=c(-22,30),xlim=c(5,45),col=rainbow(25),lty=1,lwd=2,cex=1,ylab="",xlab="Time",cex.lab=1.2,cex.axis=1.2,main="Residual functions")
#lines(PM10_fd_Bspl,col=rainbow(25),lwd=2,lty=1)
#title(ylab=expression(chi[s]^1),cex.lab=1.2,mgp=c(2.5,0,0))
loc <- par("usr")
text(loc[1.5], loc[4.3], adj = c(2.5,4),expression(bold(chi)[s]^1),xpd = T,cex=2)
```


