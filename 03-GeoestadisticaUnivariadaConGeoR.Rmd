---
output: html_document
---

# Geoestadística univariada con `geoR`

## Parte descriptiva

### Librerías

Lista de librerías con link a la documentación.

- [fields](https://cran.r-project.org/web/packages/fields/fields.pdf)
- [geoR](https://cran.r-project.org/web/packages/geoR/geoR.pdf)
- [akima](https://cran.r-project.org/web/packages/akima/akima.pdf) Usado para gráficos descriptivos

```{r}
rm(list=ls())
library(fields)
library(geoR)
library(akima)
```

### Lectura de datos

```{r}
aquifer <- read.table("data_7_GeoestadisticaGEOSTAT/aquifer.txt", head = TRUE, dec = ",")
```

Encabezado de datos `aquifer.txt`

```{r}
head(aquifer)
```

Summary de los datos `aquifer.txt`

```{r}
summary(aquifer)
```

## GEO_Data

### Convertir aquifer a un objeto geodata (geoR obj)

- Documentación [as.geodata](https://cran.r-project.org/web/packages/geoR/geoR.pdf#page=5)

```{r}
aquiferg <- as.geodata(aquifer)
summary(aquiferg)
```

### Gráfico de objeto geodata

- Documentación [plotgeodata](https://cran.r-project.org/web/packages/geoR/geoR.pdf#page=85)

Gráfico del objeto geodata

```{r}
plot(aquiferg, qt.col = c("purple",
                         "pink",
                         "green",
                         "yellow"))
```

Gráfico con el parametro 3d

```{r}
plot(aquiferg, scatter3d = T)
```

Gráfico removiendo la tendencia (trend )

```{r}
plot(aquiferg, trend = "1st")
```

### Gráficos descriptivos interpolación

- Documentación Interpolación [inderp](https://cran.r-project.org/web/packages/akima/akima.pdf#page=14)
- Documentación [persp](https://www.rdocumentation.org/packages/graphics/versions/3.6.2/topics/persp)
- Documentación [drape.plot](https://cran.r-project.org/web/packages/fields/fields.pdf#page=36)

```{r}
par(mfrow = c(2, 2),
    mar = c(3, 3, 1, 1),
    mgp = c(2, 1, 0))
# Esta función agrupa los siguientes gráficos en
# una matrix 2x2

grillas <- interp(aquifer$Este,
                  aquifer$Norte,
                  aquifer$Profundidad)

persp(grillas$x,
      grillas$y,
      grillas$z,
      xlab = "Este",
      ylab = "Norte",
      zlab = "Nivel freatico",
      phi = 30,
      theta = 20,
      col = "lightblue",
      expand = .5,
      ticktype = "detailed")

drape.plot(grillas$x,
           grillas$y,
           grillas$z,
           xlab = "Este",
           ylab = "Norte",
           zlab = "z",
           theta = 45,
           col = topo.colors(64),
           expand = .5,
           ticktype = "detailed")


drape.plot(grillas$x,
           grillas$y,
           grillas$z,
           xlab = "Este",
           ylab = "Norte",
           zlab = "z",
           theta = -10,
           col = topo.colors(64),
           expand = .5,
           ticktype = "detailed")


drape.plot(grillas$x,
           grillas$y,
           grillas$z,
           xlab = "Este",
           ylab = "Norte",
           zlab = "z",
           theta = 60,
           col = topo.colors(64),
           expand = .5,
           ticktype = "detailed")
```

### Gráficos de contorno

- Documentación [contour](https://www.rdocumentation.org/packages/graphics/versions/3.6.2/topics/contour)
- Documentación [filled.contour](https://www.rdocumentation.org/packages/graphics/versions/3.6.2/topics/filled.contour)

```{r}
par(mfrow = c(2, 1),
    mar = c(1,1,1,1))

contour(grillas, nlevels = 10, main = "Contorno")
image(grillas$z, main =  "Grilla")
```

```{r}
filled.contour(grillas, levels = seq(1000,
                                     5000,
                                     len = 10),
               col = heat.colors(10),
                main = "grilla niveles")
```

### Funciones y gráficas a partir de la función outer

```{r}
h <- seq(0, 1, len = 50)
u <- seq(0, 1, len = 50)

ejemplo1CH  <- function(h, u, sigma, a, b, c, d, delta) {
    (sigma^2/((a^2*u^2+c)^(d/2)))*exp(-(b^2*h^2)/(a^2*u^2+c))*exp(-delta*u^2)
    }
h <- seq(0, 1, len = 20)
u <- seq(1, 10, len = 20)
f <- outer(h, u, ejemplo1CH, sigma=3, a=1, b=3, c=1, d=2, delta=0)

par(mfrow = c(2, 2),
    mar = c(3, 3, 1, 1),
    mgp = c(2, 1, 0))

drape.plot(h,
           u,
           f,
           main = "Cressie-Huang; 1 (25,1,0.6)",
           xlab = "h",
           ylab = "u",
           zlab = "Covarianza",
           ltheta = 75,
           col = terrain.colors(64))

drape.plot(h,
           u,
           f,
           main = "Cressie-Huang; 1 (25,1,0.6)",
           xlab = "h",
           ylab = "u",
           zlab = "Covarianza",
           theta = -150,
           col = terrain.colors(64))
persp(h,
      u,
      f,
      main = "Cressie-Huang; 1 (25,1,0.6)",
      xlab = "h",
      ylab = "u",
      zlab = "Covarianza",
      ltheta = 75)

contour(h,
        u,
        f,
        col = topo.colors(10),
        xlim = c(0,0.6))
```

## Modelando la media con regresión polinomial

### Primer modelo

```{r}
reg1 <- lm(Profundidad ~ Este + Norte, data = aquifer)
residuales1  <-  residuals(reg1)
summary(reg1)
anova(reg1)
```

### Segundo modelo

```{r}
reg2 <- lm(Profundidad ~ Este + Norte +
           I(Este^2) + I(Norte^2) +
           I(Este * Norte),
           data = aquifer)
residuales2  <-  residuals(reg2)
summary(reg2)
anova(reg2)
```

### Tercer modelo

```{r}
reg3 <- lm(Profundidad ~ Este * Norte,
           data = aquifer)
residuales3  <-  residuals(reg3)
summary(reg3)
anova(reg3)
```

## Estimación del semivariograma empírico

- Documentación [variog](https://cran.r-project.org/web/packages/geoR/geoR.pdf#page=133)

```{r}
vari2 <- variog(aquiferg, trend = "1st")
vari2Cloud <- variog(aquiferg, op = "cloud", trend = "1st")
vari2BinCloud <- variog(aquiferg,
                       max.dist = 200,
                       op = "cloud",
                       bin.cloud = TRUE)
vari2Sm <- variog(aquiferg,
                  trend = "1st",
                  op = "sm",
                  band=11)
```

```{r}
par(mfrow = c(2, 2), mar = c(3, 3, 1, 1), mgp = c(2, 1, 0))
     plot(vari2$u, vari2$v, main = "binned variogram") # jocastroc: vari2 solo no da el plot se dejo vari2$u,vari2$v
     plot(vari2Cloud$u, vari2Cloud$v, main = "variogram cloud")
     plot(vari2BinCloud$u, vari2BinCloud$v, main = "clouds for binned variogram")
     plot(vari2Sm$u, vari2Sm$v, main = "smoothed variogram")
```

### Explorando estimación clásica, removiendo tendencia

```{r}
vari1 <- variog(aquiferg)
vari2 <- variog(aquiferg, trend = "1st")
vari3 <- variog(aquiferg, trend = "2nd")
```

```{r}
plot(vari1$u,vari1$v, main = "Sin remover tendencia")
plot(vari2$u,vari2$v, main  = "Trend 1 ")
plot(vari3$u,vari3$v, main  = "Trend 2 ")
```

### Explorando estimación resistente a datos atípicos y removiendo tendencia

```{r}
vari1 <- variog(aquiferg, estimator.type = "modulus")
vari2 <- variog(aquiferg, trend = "1st", estimator.type = "modulus")
vari3 <- variog(aquiferg, trend = "2nd", estimator.type = "modulus")
```

```{r}
plot(vari1$u,vari1$v, main = "Sin remover tendencia")
plot(vari2$u,vari2$v, main  = "Trend 1 ")
plot(vari3$u,vari3$v, main  = "Trend 2 ")
```

### Explorando anisotropía

```{r}
vari_0 <- variog(aquiferg,
                 trend = "1st",
                 max.dist = 200,
                 dir = 0)

vari_45 <- variog(aquiferg,
                  trend = "1st",
                  max.dist = 200,
                  dir = pi / 4)
vari_90 <- variog(aquiferg,
                  trend = "1st",
                  max.dist = 200,
                  dir = pi / 2)
vari_135 <- variog(aquiferg,
                   trend = "1st",
                   max.dist = 200,
                   dir = 3 * pi / 4)
par(mfrow = c(2, 2),
    mar = c(3, 3, 1, 1),
    mgp = c(2, 1, 0))

plot(vari_0$u,vari_0$v, main = "vari 0")
plot(vari_45$u,vari_45$v, main = "vari 45")
plot(vari_90$u,vari_90$v, main = "vari 90")
plot(vari_135$u,vari_135$v, main = "vari 195")
```

## Estimación teórica del semivariograma

- Documentación [eyefit](https://cran.r-project.org/web/packages/geoR/geoR.pdf#page=25)
- Documentación [variofit](https://cran.r-project.org/web/packages/geoR/geoR.pdf#page=129)
- Documentación [likfit](https://cran.r-project.org/web/packages/geoR/geoR.pdf#page=60)

```{r}
var1 <- variog(aquiferg,trend="1st",max.dist=200)


#ini1 <- eyefit(var1)
#cov.model  sigmasq phi   tausq kappa kappa2   practicalRange
#1      wave 30805.52  13 8984.94  <NA>   <NA> 38.8889336320589
ini1 <- c(30805.52, 13)
fitvar1 <- variofit(var1,
                    cov.model = "wave",
                    ini1,
                    fix.nugget = TRUE,
                    nugget = 8984.94,
                    wei = "equal")

fitvar2 <- variofit(var1,
                    cov.model = "wave",
                    ini1,
                    fix.nugget = TRUE,
                    nugget = 8984.94,
                    wei = "npairs")

fitvar3 <- variofit(var1,
                    ini1,
                    fix.nugget = TRUE,
                    nugget = 8984.94,
                    wei = "cressie")


fitvar4 <- likfit(aquiferg,
                  coords = aquiferg$coords,
                  data = aquiferg$data,
                  trend = "1st",
                  ini.cov.pars = ini1,
                  fix.nugget = T,
                  nugget = 8984.94,
                  cov.model = "wave",
                  lik.method = "ML")

fitvar5 <- likfit(aquiferg,
                  coords = aquiferg$coords,
                  data = aquiferg$data,
                  trend = "1st",
                  ini.cov.pars = ini1,
                  fix.nugget = T,
                  nugget = 8984.94,
                  cov.model = "wave",
                  lik.method = "REML")
```

```{r}
plot(var1$u,var1$v,
     xlab = "h",
     ylab = "semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma",
     col.main = 4, cex.main =1.3)
lines(fitvar1, col = 1)
lines(fitvar2, col = 2)
lines(fitvar3, col = 3)
lines(fitvar4, col = 4)
lines(fitvar5, col = 5)
legend(130, 18000,
       c("MCO", "MCPnpairs", "MCPcressie", "ML", "REML"),
       lwd = 2,
       lty = 2:7,
       col = 2:7,
       box.col = 9,
       text.col = 2:7)
```

## Resultados

```{r}
summary(fitvar1)
summary(fitvar2)
summary(fitvar3)
summary(fitvar4)
summary(fitvar5)
```


## Pulimiento de medianas

Esta es una alternativa al modelamiento de la media cuando los modelos de regresión polinómicos usuales no logran el objetivo de eliminar la tendencia ya sea porque el tipo de tendencia corresponde mas a unas ventanas móviles o porque hay presentes datos atípicos.

### Cargar librerias

Lista de librerías con link a la documentación.

```{r}
rm(list=ls())
library(gstat)
library(sp)
library(mvtnorm)
```

- [gstat](https://cran.r-project.org/web/packages/gstat/gstat.pdf)
- [sp](https://cran.r-project.org/web/packages/sp/sp.pdf)

### Grilla de las ubicaciones espaciales.

```{r}
n_x <- 4
n_y <- 6
x <- seq(0, 1, len = n_x)
y <- seq(0, 1, len = n_y)
coordenadas <- as.data.frame(expand.grid(x, y))
names(coordenadas) <- c("X", "Y")
```

Encabezado coordenadas

| X |	Y |
| --- | --- |
| 0.0000000 |	0.0 |
| 0.3333333 |	0.0 |
| 0.6666667 |	0.0 |
| 1.0000000 |	0.0 |
| 0.0000000	| 0.2 |
| 0.3333333	| 0.2 |

### Definición de objeto VGM

Esto define un objeto vgm que es el tipo de objeto que usa el paquete gstat para los modelos teóricos de variograma. Con este objeto se pueden definir modelos anidados.

- [vgm](https://cran.r-project.org/web/packages/gstat/gstat.pdf#page=73)

```{r}
vario <- vgm(10, # Punto de silla
             "Exp", # Modelo, ver documentación
             0.5)  # Rango
print(vario)
```

### Matriz de varianza dadas coordenadas.
- [vgmArea](https://cran.r-project.org/web/packages/gstat/gstat.pdf#page=78)
- [coordinates](https://cran.r-project.org/web/packages/sp/sp.pdf#page=16)

```{r}
coordinates(coordenadas) <- ~X + Y
class(coordenadas) # Cambio de objedto dataframe a sp
```

```{r}
cov_mat <- vgmArea(coordenadas, # Matriz de ubiaciones SP
        vgm = vario) # VGM object

print(dim(cov_mat))
```

### Simulación.

Simulación dada la media y la matriz de varianza

```{r}
mu  <- rep(0, n_x * n_y) # Media del proceso
simu <- rmvnorm(1,
                mean = mu,
                sigma = cov_mat)
print(simu[1:5])
```

### Pulimiento de medianas

Unir las coordenadas con la columna de simulación

```{r}
data <- as.data.frame(cbind(coordenadas@coords,
                            Simula = t(simu)))
names(data) <- c("X", "Y", "Var")
print(head(data))
```

Reshape para matriz, esto transforma la tabla de datos en matriz

```{r}
tabla <- reshape2::dcast(data,
                         X ~ Y,
                         value.var = "Var")
rownames(tabla) <- tabla[, 1]
tabla <- tabla[, c(-1)]
print(tabla)
```

Pulimiento de medianas de la tabla

```{r}
med <- medpolish(tabla)
```

```{r}
geo_data <- reshape2::melt(med$residuals)
print(med)
```

Reshape de los datos, con efecto de la fila y la columna

```{r}
tabla_residuales <- as.data.frame(med$residuals)
names(tabla_residuales) <- med$col
rownames(tabla_residuales) <- med$row
geo_data <- reshape2::melt(as.matrix(tabla_residuales))

geo_data <- cbind(data,
                  geo_data,
                  med$overall)
names(geo_data) <- c("X",
                     "Y",
                     "Var",
                     "Efecto fila",
                     "Efecto columa",
                     "Residual",
                     "Efecto Global")
print(geo_data)
```

Validación de la descomposición

```{r}
valida <- cbind(geo_data$Var,
                geo_data[["Efecto fila"]] +
                geo_data[["Efecto columa"]] +
                geo_data[["Residual"]] +
                geo_data[["Efecto Global"]])
valida <- as.data.frame(valida)
names(valida) <- c("datos", "suma")
print(valida)
```





































